<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title data-i18n="title">PDF Processor</title>
  <link rel="stylesheet" href="styles.css">
  <script src="https://cdn.jsdelivr.net/npm/pdfjs-dist@3.4.120/build/pdf.min.js"></script>
  <script>
   pdfjsLib.GlobalWorkerOptions.workerSrc = `https://cdn.jsdelivr.net/npm/pdfjs-dist@3.4.120/build/pdf.worker.min.js`;
  </script>
  <script src="https://cdn.jsdelivr.net/npm/interactjs/dist/interact.min.js"></script>
  <style>
     .editor-area {
       position: relative;
       background-color: white;
       overflow: hidden;
       border: 1px solid #ccc;
       box-sizing: border-box;
     }
     .draggable-pdf-page {
       touch-action: none;
       box-sizing: border-box;
       position: absolute;
       border: 1px dashed #007bff;
       background-size: 100% 100%;
       background-repeat: no-repeat;
       background-position: center;
     }
     .interact-resiz-handle {
       width: 10px;
       height: 10px;
       background: #007bff;
       border: 1px solid white;
       position: absolute;
     }
     .shein-label-layout {
       display: flex;
       gap: 20px;
     }
     .shein-label-controls {
       flex: 2;
       min-width: 300px;
     }
     .shein-label-editor-container {
       flex: 0.5;
       display: flex;
       flex-direction: column;
     }
     .checkbox-wrapper {
       display: flex;
       align-items: center;
     }
  </style>
</head>
<body>
  <div class="title-bar">
    <div class="title-bar-drag-region"></div>
    <div class="title-bar-text" style="display: flex; align-items: center;"><img width="30px" height="30px" src="static/pdfShdow.png" style="margin-right: 8px;">PDFShdow</div>
    <div class="title-bar-controls">
      <!-- <button id="devToolsBtn" class="title-bar-button" data-i18n-aria-label="devTools" data-i18n-title="devTools" aria-label="开发者工具" title="开发者工具">
        <svg aria-hidden="true" version="1.1" width="10" height="10"><path d="M 5,0 5,2 7,2 7,4 5,4 5,6 3,6 3,4 1,4 1,2 3,2 3,0 Z M 1,7 1,9 3,9 3,7 Z M 5,7 5,9 7,9 7,7 Z" /></svg>
      </button> -->
      <button id="websit" class="title-bar-button" onclick="electronAPI.openOfficialWebsite().catch(err => console.error(err))" data-i18n-aria-label="officialWebsite" data-i18n-title="officialWebsite" aria-label="官方网站" title="官方网站">
        <svg aria-hidden="true" version="1.1" width="12" height="12" fill="currentColor" viewBox="0 0 16 16">
          <path d="M6.5 14.5v-3.505c0-.245.25-.495.5-.495h2c.25 0 .5.25.5.5v3.5a.5.5 0 0 0 .5.5h4a.5.5 0 0 0 .5-.5v-7a.5.5 0 0 0-.146-.354L13 5.793V2.5a.5.5 0 0 0-.5-.5h-1a.5.5 0 0 0-.5.5v1.293L8.354 1.146a.5.5 0 0 0-.708 0l-6 6A.5.5 0 0 0 1.5 7.5v7a.5.5 0 0 0 .5.5h4a.5.5 0 0 0 .5-.5z"/>
        </svg>
      </button>
      <button id="updateCheckBtn" class="title-bar-button" data-i18n-aria-label="checkForUpdates" data-i18n-title="checkForUpdates" aria-label="检查更新" title="检查更新">
        <svg aria-hidden="true" version="1.1" width="12" height="12" fill="currentColor" viewBox="0 0 16 16">
          <path fill-rule="evenodd" d="M1 8a7 7 0 1 0 14 0A7 7 0 0 0 1 8zm15 0A8 8 0 1 1 0 8a8 8 0 0 1 16 0zm-7.5 3.5a.5.5 0 0 1-1 0V5.707L5.354 7.854a.5.5 0 1 1-.708-.708l3-3a.5.5 0 0 1 .708 0l3 3a.5.5 0 0 1-.708.708L8.5 5.707V11.5z"/>
        </svg>
      </button>
      <button id="downloadStatusBtn" class="title-bar-button" data-i18n-aria-label="downloadStatus" data-i18n-title="downloadStatus" aria-label="下载状态" title="下载状态" style="display: none;">
       <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-download" viewBox="0 0 16 16">
         <path d="M.5 9.9a.5.5 0 0 1 .5.5v2.5a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1v-2.5a.5.5 0 0 1 1 0v2.5a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2v-2.5a.5.5 0 0 1 .5-.5z"/>
         <path d="M7.646 11.854a.5.5 0 0 0 .708 0l3-3a.5.5 0 0 0-.708-.708L8.5 10.293V1.5a.5.5 0 0 0-1 0v8.793L5.354 8.146a.5.5 0 1 0-.708.708l3 3z"/>
       </svg>
      </button>
      <button id="minimize-btn" class="title-bar-button" data-i18n-aria-label="minimize" aria-label="最小化">
        <svg aria-hidden="true" version="1.1" width="10" height="10"><path d="M 0,5 10,5 10,6 0,6 Z" /></svg>
      </button>
      <button id="maximize-restore-btn" class="title-bar-button" data-i18n-aria-label="maximize" aria-label="最大化">
        <svg aria-hidden="true" version="1.1" width="10" height="10"><path d="M 0,0 0,10 10,10 10,0 Z M 1,1 9,1 9,9 1,9 Z" /></svg>
      </button>
      <button id="close-btn" class="title-bar-button" data-i18n-aria-label="close" aria-label="关闭">
        <svg aria-hidden="true" version="1.1" width="10" height="10"><path d="M 0,0 0,0.7 4.3,5 0,9.3 0,10 0.7,10 5,5.7 9.3,10 10,10 10,9.3 5.7,5 10,0.7 10,0 9.3,0 5,4.3 0.7,0 Z" /></svg>
      </button>
    </div>
  </div>
  <div class="app-layout">
    <aside class="sidebar">
      <div class="sidebar-header">
        <h2 data-i18n="navigation">功能导航</h2>
      </div>
      <nav>
        <ul>
          <li><a href="#" class="nav-link active" data-view="sheinLabelView" data-i18n="sheinLabelGenerator">Shein 标签 生成</a></li>
          <li><a href="#" class="nav-link" data-view="pdfResizeView" data-i18n="pdfResizer">PDF 尺寸调整</a></li>
        </ul>
      </nav>
      <div class="sidebar-footer">
        <div class="sidebar-controls">
          <div class="language-selector-wrapper">
            <select id="languageSelector" class="sidebar-select">
              <option value="zh-CN">简体中文</option>
              <option value="en">English</option>
            </select>
          </div>
          <div id="themeToggleSwitch" class="theme-switch-wrapper" title-i18n="themeToggle" title="切换主题">
            <div class="theme-switch-track">
              <div class="theme-switch-thumb">
                <span class="sun-icon">☀️</span>
                <span class="moon-icon">🌙</span>
              </div>
            </div>
          </div>
        </div>
        <div class="theme-notice" data-i18n="version" data-i18n-options='{"version": "0.0.2"}'>版本号: 0.0.2</div>
        <div class="theme-notice" data-i18n="disclaimer">仅供学习交流使用，不可商用</div>
      </div>
    </aside>

    <main class="main-content">
      <div class="view-container" id="pdfResizeView" style="display: none;">
        <!-- Existing content will be wrapped by its own .container if needed, or styled directly -->
        <div class="container"> <!-- This is the original .container -->
          <div class="title-with-description">
            <h2 data-i18n="pdfResizer">PDF 尺寸调整</h2>
            <span class="feature-description" data-i18n="pdfResizerDescription">调整所选 PDF 文件的页面尺寸，支持预设尺寸和自定义尺寸。</span>
          </div>
          
          <div class="section">
            <div class="field-wrapper"> <!-- Added wrapper for layout with error message -->
              <button id="openFile" class="btn-primary" data-i18n="selectPdfFile">选择 PDF 文件</button>
              <span id="selectedFile" class="file-select-status-span"></span>
              <span class="field-hint" data-i18n="pdfForResizeHint">待调整尺寸的PDF</span>
              <small class="error-message" id="selectedFileError"></small> <!-- New error message placeholder -->
            </div>
          </div>
      
          <div class="section">
            <div class="field-wrapper">
              <button id="selectOutputDirBtn" class="btn-secondary" data-i18n="selectOutputDirectory">选择输出目录</button>
              <span id="outputDirDisplay" class="file-select-status-span" data-i18n="notSetUseDefault"></span>
              <span class="field-hint" data-i18n="outputDirectoryHint">选择一个文件夹来保存所有生成的文件</span>
            </div>
          </div>

          <div class="section">
            <label for="pdfResizeOutputName"><span data-i18n="fileName">文件名称</span> <span class="field-hint" data-i18n="outputFileNameHint">输出文件名,不含扩展名</span></label>
            <input type="text" id="pdfResizeOutputName" data-i18n-placeholder="exampleResized" placeholder="例如: resized_document">
          </div>
      
          <div class="section">
            <label for="pageSize"><span data-i18n="pageSize">页面尺寸</span> <span class="field-hint" data-i18n="selectPresetOrCustom">选择预设或自定义</span></label>
            <div class="custom-select-wrapper">
              <select id="pageSize" style="display:none;">
                <option value="A4">A4 (210x297mm)</option>
                <option value="Shein" selected>Shein (70x60mm)</option>
                <option value="custom" data-i18n="custom">自定义</option>
              </select>
              <div class="custom-select-container" id="customPageSizeSelect">
                <div class="custom-select-trigger"><span>Shein (70x60mm)</span><div class="arrow"></div></div>
                <div class="custom-select-options">
                  {/* Options will be populated by JS */}
                </div>
              </div>
            </div>
            <div id="customSize" class="dimension-inputs-container" style="display: none;">
              <div class="field-wrapper">
                <div class="input-group">
                  <input type="number" id="customWidth" data-i18n-placeholder="width" placeholder="宽度">
                  <span class="unit">mm</span>
                </div>
                <span class="field-hint" data-i18n="customWidthHint">自定义宽度,毫米</span>
                <small class="error-message" id="customWidthError"></small>
              </div>
              <div class="field-wrapper">
                <div class="input-group">
                  <input type="number" id="customHeight" data-i18n-placeholder="height" placeholder="高度">
                  <span class="unit">mm</span>
                </div>
                <span class="field-hint" data-i18n="customHeightHint">自定义高度,毫米</span>
                <small class="error-message" id="customHeightError"></small>
              </div>
            </div>
          </div>
      
          <div class="action-buttons-row" style="display: flex; margin-bottom: 10px;">
            <button id="processBtn" class="btn-primary" data-i18n="startProcessing">开始处理</button> <!-- Removed flex-grow: 1 -->
            <button id="clearPdfResizeFormBtn" class="btn-secondary" style="margin-left: 10px;" data-i18n="clear">清空</button>
          </div>
          <div id="result"></div>
          <div id="pdfResizePostProcessActions" style="margin-top: 10px; display: none;">
            <!-- <button id="pdfResizeOpenGeneratedFileBtn" class="action-button">打开文件</button>
            <button id="pdfResizeShowGeneratedFileInFolderBtn" class="action-button">打开文件夹</button>
            <button id="pdfResizeCopyFileBtn" class="action-button" title="尝试复制文件到剪贴板 (若失败则复制路径)">复制文件</button> -->
          </div>
        </div>
      </div>

      <div class="view-container" id="sheinLabelView" style="display: block;">
        <div class="container">
          <div class="title-with-description">
            <h2 data-i18n="sheinLabelGenerator">Shein 标签 生成</h2>
            <span class="feature-description" data-i18n="sheinLabelGeneratorDescription">合并欧代和条码 PDF，生成符合 Shein 要求的标签。</span>
          </div>
          <div class="shein-label-layout">
            <div class="shein-label-controls">
              <div class="section">
                <div class="field-wrapper">
                  <button id="sheinOpenFile1Btn" class="btn-primary" data-i18n="selectEcRepFile">选择欧代文件</button>
                  <span id="sheinSelectedFile1" class="file-select-status-span" data-i18n="noFileSelected"></span>
                  <span class="field-hint" data-i18n="ecRepPdfHint">欧代PDF文件</span>
                  <small class="error-message" id="sheinSelectedFile1Error"></small>
                </div>
              </div>
              <div class="section">
                <div class="field-wrapper">
                  <button id="sheinOpenFile2Btn" class="btn-primary" data-i18n="selectBarcodeFile">选择条码文件</button>
                  <span id="sheinSelectedFile2" class="file-select-status-span" data-i18n="noFileSelected"></span>
                  <span class="field-hint" data-i18n="barcodePdfHint">条码PDF文件</span>
                  <small class="error-message" id="sheinSelectedFile2Error"></small>
                </div>
              </div>
              <div class="section">
                <div class="field-wrapper">
                  <button id="sheinSelectOutputDirBtn" class="btn-secondary" data-i18n="selectOutputDirectory">选择输出目录</button>
                  <span id="sheinOutputDirDisplay" class="file-select-status-span" data-i18n="notSetUseDefault"></span>
                  <span class="field-hint" data-i18n="outputDirectoryHint">选择一个文件夹来保存所有生成的文件</span>
                </div>
              </div>
              <div class="section">
                <label for="sheinOutputName"><span data-i18n="fileName">文件名称</span> <span class="field-hint" data-i18n="sheinOutputFileNameHint">Shein标签输出文件名</span></label>
                <input type="text" id="sheinOutputName" data-i18n-placeholder="exampleSheinOutput" placeholder="例如: shein_label_output">
              </div>
              <div class="section">
                <label for="sheinOutputPageSize"><span data-i18n="pageSize">页面尺寸</span> <span class="field-hint" data-i18n="sheinOutputPageSize">Shein标签输出尺寸</span></label>
                <div class="custom-select-wrapper">
                  <select id="sheinOutputPageSize" style="display:none;">
                    <option value="A4">A4 (210x297mm)</option>
                    <option value="Shein" selected>Shein (70x60mm)</option>
                    <option value="custom" data-i18n="custom">自定义</option>
                  </select>
                  <div class="custom-select-container" id="customSheinOutputPageSizeSelect">
                    <div class="custom-select-trigger"><span>Shein (70x60mm)</span><div class="arrow"></div></div>
                    <div class="custom-select-options">
                    </div>
                  </div>
                </div>
                <div id="sheinOutputCustomDimensions" class="dimension-inputs-container" style="display: none;">
                  <div class="field-wrapper">
                    <div class="input-group">
                      <input type="number" id="sheinOutputWidth" data-i18n-placeholder="width" placeholder="宽度" value="70">
                      <span class="unit">mm</span>
                    </div>
                    <span class="field-hint" data-i18n="labelWidthHint">标签宽度,毫米</span>
                    <small class="error-message" id="sheinOutputWidthError"></small>
                  </div>
                  <div class="field-wrapper">
                    <div class="input-group">
                      <input type="number" id="sheinOutputHeight" data-i18n-placeholder="height" placeholder="高度" value="60">
                      <span class="unit">mm</span>
                    </div>
                    <span class="field-hint" data-i18n="labelHeightHint">标签高度,毫米</span>
                    <small class="error-message" id="sheinOutputHeightError"></small>
                  </div>
                </div>
              </div>
              <div class="action-buttons-row" style="display: flex; margin-bottom: 10px;">
                <button id="generateSheinLabelBtn" class="btn-primary" data-i18n="generateSheinLabel">生成 Shein 标签</button>
                <button id="clearSheinLabelFormBtn" class="btn-secondary" style="margin-left: 10px;" data-i18n="clear">清空</button>
              </div>
              <div id="sheinResult"></div>
              <div id="sheinPostProcessActions" style="margin-top: 10px; display: none;">
              </div>
            </div>
            <div class="shein-label-editor-container">
              <div class="section">
                <div style="display: flex; justify-content: space-between; align-items: center;">
                  <label data-i18n="editorArea">编辑区域</label>
                  <div class="checkbox-wrapper">
                    <input type="checkbox" id="sheinKeepAspectRatio" checked>
                    <label for="sheinKeepAspectRatio" data-i18n="keepAspectRatio">固定高宽比</label>
                  </div>
                </div>
                <div id="shein-editor-area" class="editor-area">
                </div>
                <span class="field-hint" data-i18n="editorAreaHint">在此区域调整欧代和条码的位置与大小。白色背景区域为最终输出大小。</span>
              </div>
            </div>
          </div>
        </div>
      </div>
    </main>
  </div>

  <!-- <script src="renderer.js"></script> -->
  <script>
  document.addEventListener('DOMContentLoaded', () => {
    // --- i18n ---
    let currentTranslations = {};

    async function loadTranslations(lang) {
      try {
        const response = await fetch(`./locales/${lang}.json`);
        if (!response.ok) {
          console.error(`Could not load translation file for ${lang}.`);
          return;
        }
        currentTranslations = await response.json();
        translatePage();
      } catch (error) {
        console.error(`Error loading or parsing translation file for ${lang}:`, error);
      }
    }

    function translatePage() {
      document.querySelectorAll('[data-i18n], [data-i18n-placeholder], [data-i18n-title], [data-i18n-aria-label]').forEach(element => {
        const key = element.getAttribute('data-i18n') || element.getAttribute('data-i18n-placeholder') || element.getAttribute('data-i18n-title') || element.getAttribute('data-i18n-aria-label');
        if (currentTranslations[key]) {
          if (element.hasAttribute('data-i18n-placeholder')) {
            element.placeholder = currentTranslations[key];
          }
          if (element.hasAttribute('data-i18n-title')) {
            element.title = currentTranslations[key];
          }
          if (element.hasAttribute('data-i18n-aria-label')) {
            element.setAttribute('aria-label', currentTranslations[key]);
          }
          if (element.hasAttribute('data-i18n')) {
            element.textContent = currentTranslations[key];
          }
        }
      });
    }

    const languageSelector = document.getElementById('languageSelector');
    languageSelector.addEventListener('change', async (event) => {
      const newLang = event.target.value;
      appSettings.language = newLang;
      await window.electronAPI.saveSettings(appSettings);
      await loadTranslations(newLang);
    });

    // --- Settings Persistence using Electron IPC ---
    // Note: saveToLocalStorage and loadFromLocalStorage are removed.
    // We will use window.electronAPI.getSettings() and window.electronAPI.saveSettings()

    let appSettings = {}; // Holds all application settings

    // --- Sidebar navigation and View Persistence ---
    const navLinks = document.querySelectorAll('.sidebar .nav-link');
    const views = document.querySelectorAll('.main-content .view-container');
    const defaultViewId = 'sheinLabelView';

    // Function to activate a view and save it
    const activateView = async (viewId) => {
      let viewActivated = false;
      views.forEach(view => {
        if (view.id === viewId) {
          view.style.display = 'block';
          viewActivated = true;
        } else {
          view.style.display = 'none';
        }
      });

      navLinks.forEach(l => {
        if (l.getAttribute('data-view') === viewId) {
          l.classList.add('active');
        } else {
          l.classList.remove('active');
        }
      });

      if (viewActivated) {
        appSettings.activeView = viewId;
        await window.electronAPI.saveSettings(appSettings);
      }
      return viewActivated;
    };
    
    navLinks.forEach(link => {
      link.addEventListener('click', async function(event) { // Made async
        event.preventDefault();
        const viewId = this.getAttribute('data-view');
        await activateView(viewId); // Made await
      });
    });

    // Helper function to get basename using pure JavaScript (as a fallback)
    function getBasenameFrontend(filePath) {
      if (!filePath || typeof filePath !== 'string') {
        return '';
      }
      // Replace all backslashes with forward slashes for consistent parsing
      const normalizedPath = filePath.replace(/\\/g, '/');
      const lastSlashIndex = normalizedPath.lastIndexOf('/');
      if (lastSlashIndex === -1) {
        return normalizedPath; // No slashes, the whole path is the filename
      }
      return normalizedPath.substring(lastSlashIndex + 1);
    }

    function getDirnameFrontend(filePath) {
      if (!filePath || typeof filePath !== 'string') {
        return '';
      }
      const normalizedPath = filePath.replace(/\\/g, '/');
      const lastSlashIndex = normalizedPath.lastIndexOf('/');
      if (lastSlashIndex === -1) {
        return ''; // No directory part
      }
      return normalizedPath.substring(0, lastSlashIndex);
    }

    function getFilenameWithoutExtension(filePath) {
      if (!filePath || typeof filePath !== 'string') {
        return '';
      }
      const basename = getBasenameFrontend(filePath);
      const lastDotIndex = basename.lastIndexOf('.');
      if (lastDotIndex === -1) {
        return basename; // No extension
      }
      return basename.substring(0, lastDotIndex);
    }

    function getCurrentHHMMSS() {
      const now = new Date();
      const hours = String(now.getHours()).padStart(2, '0');
      const minutes = String(now.getMinutes()).padStart(2, '0');
      const seconds = String(now.getSeconds()).padStart(2, '0');
      return `${hours}${minutes}${seconds}`;
    }

    // Function to get the output filename suffix for PDF Resize based on selected/custom dimensions
    function getOutputSuffixForPdfResize() {
      const pageSizeSelect = document.getElementById('pageSize');
      const customWidthInput = document.getElementById('customWidth');
      const customHeightInput = document.getElementById('customHeight');

      if (!pageSizeSelect) return '_未知尺寸'; // Fallback

      const selectedPageSizeValue = pageSizeSelect.value;
      let width = '';
      let height = '';

      if (selectedPageSizeValue === 'custom') {
        width = customWidthInput ? customWidthInput.value.trim() : '';
        height = customHeightInput ? customHeightInput.value.trim() : '';
        if (width && height && !isNaN(parseFloat(width)) && parseFloat(width) > 0 && !isNaN(parseFloat(height)) && parseFloat(height) > 0) {
          return `_${parseFloat(width)}x${parseFloat(height)}`;
        } else {
          return '_自定义'; // Or some other indicator of custom but invalid/incomplete
        }
      } else {
        const presetDimensions = pageSizeMapMM[selectedPageSizeValue]; // pageSizeMapMM should be defined
        if (presetDimensions) {
          return `_${presetDimensions.width}x${presetDimensions.height}`;
        }
      }
      return '_预设'; // Fallback for unknown preset
    }

    function formatBytes(bytes, decimals = 2) {
      if (bytes === null || bytes === undefined || isNaN(parseFloat(bytes)) || !isFinite(bytes) || bytes === 0) return '0 Bytes';
      const k = 1024;
      const dm = decimals < 0 ? 0 : decimals;
      const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'];
      const i = Math.floor(Math.log(bytes) / Math.log(k));
      return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
    }

    function updateFileSelectionUI(filePath, spanElementId, pageCount = null, fileSize = null, isLoadingMetadata = false) {
      const spanElement = document.getElementById(spanElementId);
      if (!spanElement) return;

      if (filePath && typeof filePath === 'string' && filePath.trim() !== '') {
        let displayText = getBasenameFrontend(filePath);
        if (isLoadingMetadata) {
          displayText += ` ${currentTranslations.gettingInfo || '(getting info...)'}`;
        } else {
          let details = [];
          if (pageCount !== null && pageCount !== undefined) {
            details.push(`${currentTranslations.pageCount.replace('{count}', pageCount) || `Pages: ${pageCount}`}`);
          }
          if (fileSize !== null && fileSize !== undefined) {
            details.push(`${currentTranslations.fileSize.replace('{size}', formatBytes(fileSize)) || `Size: ${formatBytes(fileSize)}`}`);
          }
          if (details.length > 0) {
            displayText += ` (${details.join(', ')})`;
          }
        }
        spanElement.textContent = displayText;
        spanElement.classList.add('file-selected-badge');
      } else {
        spanElement.textContent = currentTranslations.noFileSelected || '未选择文件';
        spanElement.classList.remove('file-selected-badge');
      }
    }
// Function to validate filename against Windows and macOS restricted characters
    function isValidFilename(filename) {
      if (!filename || typeof filename !== 'string') {
        return { valid: true };
      }
      // Windows reserved characters (including / which is also for macOS)
      // eslint-disable-next-line no-control-regex
      const windowsReservedChars = /[<>;:"/\\|?*\x00-\x1F]/g;
      // macOS reserved characters (colon is already in windowsReservedChars, / is also covered)
      // Technically, macOS only forbids ':' and '/', but '/' is path separator everywhere.
      // For simplicity and broader compatibility, we'll stick to the Windows set as it's more restrictive.

      if (windowsReservedChars.test(filename)) {
        return { valid: false, message: '文件名包含无效字符 (例如: &lt; &gt; : " / \\ | ? *)。请移除这些字符。' };
      }

      // Windows reserved filenames (case-insensitive)
      const reservedNames = /^(CON|PRN|AUX|NUL|COM[1-9]|LPT[1-9])$/i;
      // Remove extension before checking reserved names
      const nameWithoutExtension = filename.includes('.') ? filename.substring(0, filename.lastIndexOf('.')) : filename;
      if (reservedNames.test(nameWithoutExtension)) {
        return { valid: false, message: '文件名是系统保留名称 (例如: CON, PRN, AUX, NUL, COM1-9, LPT1-9)。请输入其他名称。' };
      }

      if (filename.startsWith(' ') || filename.endsWith(' ') || filename.endsWith('.')) {
        return { valid: false, message: '文件名不能以空格开头或结尾，也不能以点号结尾。' };
      }
      
      if (filename.length > 255) { // Common file system limit
        return { valid: false, message: '文件名过长 (最多255个字符)。' };
      }

      return { valid: true, message: '' };
    }
    
    // Function to clear specific inline error associated with a file input
    function clearInlineFileError(errorElementId) {
        const errorEl = document.getElementById(errorElementId);
        if (errorEl) {
            errorEl.textContent = '';
            errorEl.style.display = 'none';
            errorEl.classList.remove('warning-text'); // Remove warning class if it was added
        }
    }


    // Custom Title Bar Logic
    const minimizeBtn = document.getElementById('minimize-btn');
    const maximizeRestoreBtn = document.getElementById('maximize-restore-btn');
    const closeBtn = document.getElementById('close-btn');

    if (minimizeBtn) {
      minimizeBtn.addEventListener('click', () => {
        if (window.electronAPI && typeof window.electronAPI.minimizeWindow === 'function') {
          window.electronAPI.minimizeWindow();
        }
      });
    }

    if (maximizeRestoreBtn) {
      maximizeRestoreBtn.addEventListener('click', () => {
        if (window.electronAPI && typeof window.electronAPI.maximizeRestoreWindow === 'function') {
          window.electronAPI.maximizeRestoreWindow();
        }
      });
    }

    if (closeBtn) {
      closeBtn.addEventListener('click', () => {
        if (window.electronAPI && typeof window.electronAPI.closeWindow === 'function') {
          window.electronAPI.closeWindow();
        }
      });
    }

    // 开发者工具按钮事件
    const devToolsBtn = document.getElementById('devToolsBtn');
    if (devToolsBtn) {
      devToolsBtn.addEventListener('click', () => {
        if (window.electronAPI && typeof window.electronAPI.toggleDevTools === 'function') {
          window.electronAPI.toggleDevTools();
        }
      });
    }

    // 检查更新按钮事件
    const updateCheckBtn = document.getElementById('updateCheckBtn');
    if (updateCheckBtn) {
      updateCheckBtn.addEventListener('click', () => {
        if (window.electronAPI && typeof window.electronAPI.checkForUpdates === 'function') {
          window.electronAPI.checkForUpdates();
        }
      });
    }

    // Update maximize/restore button icon based on window state
    const maximizeIcon = '<svg aria-hidden="true" version="1.1" width="10" height="10"><path d="M 0,0 0,10 10,10 10,0 Z M 1,1 9,1 9,9 1,9 Z" /></svg>';
    const restoreIcon = '<svg aria-hidden="true" version="1.1" width="10" height="10"><path d="m 2,1e-5 0,2 -2,0 0,8 8,0 0,-2 2,0 0,-8 z m 1,1 6,0 0,6 -1,0 0,-5 -5,0 z m -2,2 6,0 0,6 -6,0 z" /></svg>';

    if (window.electronAPI && typeof window.electronAPI.onWindowMaximized === 'function') {
      window.electronAPI.onWindowMaximized(() => {
        if (maximizeRestoreBtn) {
          maximizeRestoreBtn.innerHTML = restoreIcon;
          maximizeRestoreBtn.setAttribute('aria-label', currentTranslations.restore || 'Restore');
        }
      });
    }

    if (window.electronAPI && typeof window.electronAPI.onWindowUnmaximized === 'function') {
      window.electronAPI.onWindowUnmaximized(() => {
        if (maximizeRestoreBtn) {
          maximizeRestoreBtn.innerHTML = maximizeIcon;
          maximizeRestoreBtn.setAttribute('aria-label', currentTranslations.maximize || 'Maximize');
        }
      });
    }
    // End Custom Title Bar Logic

    const themeToggleSwitch = document.getElementById('themeToggleSwitch');

    async function setTheme(theme, save = true) { // Added save parameter
      const isDark = theme === 'dark';
      document.body.classList.toggle('dark-mode', isDark);
      themeToggleSwitch.classList.toggle('active', isDark);

      if (save) {
        appSettings.theme = theme;
        await window.electronAPI.saveSettings(appSettings);
      }
    }

    themeToggleSwitch.addEventListener('click', async () => {
      const newTheme = document.body.classList.contains('dark-mode') ? 'light' : 'dark';
      await setTheme(newTheme);
    });

    // Function to show toast notifications
    function showToast(message, type = 'info', duration = 3500) {
      const container = document.getElementById('toastContainer');
      if (!container) {
        console.error('Toast container not found!');
        return;
      }

      const toast = document.createElement('div');
      toast.className = `toast toast-${type}`; // e.g., "toast toast-success"
    
      // --- Add logging and default message for debugging ---
      console.log(`showToast called with message: "${message}", type: "${type}"`);
      const displayMessage = (message && typeof message === 'string' && message.trim() !== '') ? message : "[默认测试提示]";
      toast.textContent = displayMessage;
      // --- End of debugging addition ---
    
      container.appendChild(toast);

      // Remove the toast after its animation finishes
      // The 'duration' parameter (default 3500ms) is how long the toast stays fully visible
      // before starting to fade out.
      const fadeOutAnimationDuration = 400; // Must match the CSS animation duration for .fade-out (0.4s)

      setTimeout(() => {
        toast.classList.add('fade-out'); // Add class to trigger CSS fade-out animation

        // Remove the toast from DOM after the fade-out animation completes
        setTimeout(() => {
          if (toast.parentNode === container) {
            container.removeChild(toast);
          }
        }, fadeOutAnimationDuration);
      }, duration); // 'duration' is when the fade-out should start
    }

    // --- Standardized Error Handling for Toasts ---
    /**
     * Handles API errors and displays a standardized toast message.
     * @param {object} apiResult - The result object from an API call, expected to have an 'error' property if failed.
     * @param {string} featureName - The name of the feature where the error occurred (e.g., "PDF尺寸调整").
     * @param {string} [defaultApiErrorMsg='操作失败。请检查文件或设置，然后重试。'] - Default message if apiResult.error is not specific.
     * @param {HTMLElement|null} [resultDiv=null] - Optional result div to clear/hide.
     * @param {HTMLElement|null} [postProcessActionsDiv=null] - Optional post-process actions div to hide.
     */
    function handleAndShowApiError(apiResult, featureName, defaultApiErrorMsg = '操作失败。请检查文件或设置，然后重试。', resultDiv = null, postProcessActionsDiv = null) {
      const errorMessage = (apiResult && apiResult.error) ? apiResult.error : defaultApiErrorMsg;
      showToast(`${featureName}失败：${errorMessage}`, 'error');
      if (resultDiv) {
        resultDiv.innerHTML = '';
        resultDiv.style.display = 'none';
        resultDiv.className = '';
      }
      if (postProcessActionsDiv) {
        postProcessActionsDiv.style.display = 'none';
      }
    }

    /**
     * Handles client-side JavaScript errors and displays a standardized toast message.
     * @param {Error} errorObject - The JavaScript Error object.
     * @param {string} featureName - The name of the feature where the error occurred.
     * @param {string} [defaultClientErrorMsg='客户端发生意外错误，请重试。'] - Default message if errorObject.message is not specific.
     * @param {HTMLElement|null} [resultDiv=null] - Optional result div to clear/hide and show client error.
     * @param {HTMLElement|null} [postProcessActionsDiv=null] - Optional post-process actions div to hide.
     */
    function handleAndShowClientError(errorObject, featureName, defaultClientErrorMsg = '客户端发生意外错误，请重试。', resultDiv = null, postProcessActionsDiv = null) {
      const errorMessage = errorObject.message ? errorObject.message : defaultClientErrorMsg;
      showToast(`${featureName}出错：${errorMessage}`, 'error');
      if (resultDiv) {
        resultDiv.innerHTML = `<p>客户端错误: ${errorMessage}</p>`;
        resultDiv.className = 'error';
        resultDiv.style.display = 'block';
      }
      if (postProcessActionsDiv) {
        postProcessActionsDiv.style.display = 'none';
      }
    }
    // --- End Standardized Error Handling ---

    // --- Listener for Toasts from Main Process ---
    if (window.electronAPI && typeof window.electronAPI.onShowToast === 'function') {
      window.electronAPI.onShowToast((message, type, duration) => {
        showToast(message, type, duration);
      });
    } else {
      console.error('Error: window.electronAPI.onShowToast is not available. Toasts from main process will not be shown.');
    }
    // --- End Listener for Toasts from Main Process ---

    // --- Update Notification Logic ---
    if (window.electronAPI && typeof window.electronAPI.onUpdateStatus === 'function') {
      const updateNotificationContainer = document.getElementById('updateNotificationContainer');
      const downloadStatusBtn = document.getElementById('downloadStatusBtn');
      let activeNotifications = {}; // Use an object to manage the notification

      const closeNotification = (notificationElement) => {
        if (notificationElement) {
          notificationElement.classList.add('fade-out');
          setTimeout(() => {
            if (notificationElement.parentNode) {
              notificationElement.parentNode.removeChild(notificationElement);
            }
            if (activeNotifications.update) {
                delete activeNotifications.update;
            }
            if (downloadStatusBtn) {
              downloadStatusBtn.style.display = 'none';
              downloadStatusBtn.classList.remove('active');
            }
          }, 500); // Match CSS animation duration
        }
      };

      if (downloadStatusBtn) {
        downloadStatusBtn.addEventListener('click', () => {
          const notification = activeNotifications.update;
          if (notification) {
            const isHidden = notification.style.display === 'none';
            notification.style.display = isHidden ? 'flex' : 'none';
            downloadStatusBtn.classList.toggle('active', isHidden);
          }
        });
      }

      const createOrUpdateNotification = (data) => {
        let notification = activeNotifications.update;

        // Do not create a notification for statuses that are handled by toasts or dialogs.
        if (!notification && ['download-started', 'downloading', 'downloaded', 'error'].includes(data.status)) {
          notification = document.createElement('div');
          notification.className = 'update-notification';
          activeNotifications.update = notification;
          updateNotificationContainer.appendChild(notification);
          
          if (downloadStatusBtn) {
            downloadStatusBtn.style.display = 'flex'; // Show the button
            downloadStatusBtn.classList.add('active'); // Mark as active
          }
        } else if (!notification) {
          return; // Don't create for other statuses if no notification exists
        }

        let title = '软件更新';
        let message = '';
        let showProgressBar = false;
        let progressPercent = 0;

        switch (data.status) {
          case 'checking':
          case 'available':
          case 'not-available':
            // These are handled by dialogs or toasts, not this persistent notification.
            return;
          case 'download-started':
            title = `发现新版本 v${data.version}`;
            message = '正在准备下载...';
            showProgressBar = true;
            progressPercent = 0;
            break;
          case 'downloading':
            title = `正在下载最新版本`;
            message = `下载速度: ${data.progress.bytesPerSecond ? formatBytes(data.progress.bytesPerSecond) + '/s' : '...'} <br> 已下载: ${data.progress.transferred ? formatBytes(data.progress.transferred) : '...'} / ${data.progress.total ? formatBytes(data.progress.total) : '...'}`;
            showProgressBar = true;
            progressPercent = data.progress.percent || 0;
            break;
          case 'downloaded':
            title = `新版本 v${data.version} 已就绪`;
            message = '下载完成。重启应用即可完成安装。';
            showProgressBar = false;
            // Don't auto-close, wait for user to restart. The button remains.
            break;
          case 'error':
            title = '更新失败';
            message = `更新过程中发生错误: ${data.error || '未知错误'}`;
            showProgressBar = false;
            break;
          default:
            // Don't show notification for unknown status, and close existing one if any.
            closeNotification(notification);
            return;
        }

        notification.innerHTML = `
          <div class="update-notification-header">
            <h4>${title}</h4>
          </div>
          <div class="update-notification-body">
            <p>${message}</p>
          </div>
          ${showProgressBar ? `
            <div class="update-progress-container">
              <div class="update-progress-bar" style="width: ${progressPercent.toFixed(2)}%;"></div>
            </div>
          ` : ''}
        `;
        
        if (data.status === 'error') {
          setTimeout(() => closeNotification(notification), 8000);
        }
      };

      window.electronAPI.onUpdateStatus((data) => {
        console.log('Update status received in renderer:', data);
        createOrUpdateNotification(data);
      });
    } else {
      console.error('Error: window.electronAPI.onUpdateStatus is not available.');
    }

    // For PDF Resize View Post-Process Actions
    const pdfResizePostProcessActionsDiv = document.getElementById('pdfResizePostProcessActions');
    const pdfResizeOpenGeneratedFileBtn = document.getElementById('pdfResizeOpenGeneratedFileBtn');
    const pdfResizeShowGeneratedFileInFolderBtn = document.getElementById('pdfResizeShowGeneratedFileInFolderBtn');
    const pdfResizeCopyFileBtn = document.getElementById('pdfResizeCopyFileBtn');
    let currentGeneratedPdfResizePath = ''; // To store the path for these buttons

    const pageSizeMap = {
      'A4': { width: 210 * 2.835, height: 297 * 2.835 }, // mm转pt
      'Letter': { width: 215.9 * 2.835, height: 279.4 * 2.835 },
      'Shein': { width: 70 * 2.835, height: 60 * 2.835 }, // mm转pt
      'custom': null
    }

    const pageSizeMapMM = { // For populating MM inputs
      'A4': { width: 210, height: 297 },
      'Letter': { width: 215.9, height: 279.4 },
      'Shein': { width: 70, height: 60 }
    };

    let selectedFilePath = ''

    document.getElementById('openFile').addEventListener('click', async () => {
      const newPath = await window.electronAPI.openFile();
      const selectedFileErrorEl = document.getElementById('selectedFileError');
      const openFileButton = document.getElementById('openFile');

      if (!newPath) {
        showToast('操作已取消。', 'info');
        // If a file was previously selected, and now cancelled, selectedFilePath might still hold old path.
        // We should update UI to "未选择文件" if cancellation truly means no file.
        // If selectedFilePath is already empty or user cancels, updateFileSelectionUI will handle it.
        // No specific metadata fetch needed if no new path.
        // updateFileSelectionUI(selectedFilePath, 'selectedFile'); // Update with current selectedFilePath (might be old or empty)
      } else {
        selectedFilePath = newPath;
        appSettings.pdfResizeSelectedPath = selectedFilePath;
        // Immediately update UI to show filename and loading state
        updateFileSelectionUI(selectedFilePath, 'selectedFile', null, null, true);

        try {
          const metadata = await window.electronAPI.getPdfMetadata(selectedFilePath);
          // Now update with full metadata
          if (metadata.success) {
            updateFileSelectionUI(selectedFilePath, 'selectedFile', metadata.pageCount, metadata.size, false);
            if (openFileButton) openFileButton.classList.remove('input-error');
            if (selectedFileErrorEl) {
                selectedFileErrorEl.textContent = '';
                selectedFileErrorEl.style.display = 'none';
            }
          } else {
            showToast(`无法读取文件元数据: ${metadata.error || '未知错误'}`, 'error');
            updateFileSelectionUI(selectedFilePath, 'selectedFile', null, null, false); // Show filename at least, remove loading
          }
        } catch (err) {
          showToast(`获取文件元数据时出错: ${err.message}`, 'error');
          updateFileSelectionUI(selectedFilePath, 'selectedFile', null, null, false); // Show filename at least, remove loading
        }

        // Update output directory display if not globally set
        // Update output directory display if not globally set
        if (!appSettings.outputDirectory) {
          const dirName = getDirnameFrontend(selectedFilePath);
          const outputDirDisplay = document.getElementById('outputDirDisplay');
          const defaultDirText = currentTranslations.notSetUseDefault || '未设置，使用源文件目录';
          // Only update if the display is still showing the default text.
          if (dirName && outputDirDisplay.textContent === defaultDirText) {
            const displayText = `${currentTranslations.currentPath || '当前路径'}: ${dirName}`;
            outputDirDisplay.textContent = displayText;
          }
        }

        // Auto-fill output name for PDF Resize
        const pdfResizeOutputNameInput = document.getElementById('pdfResizeOutputName');
        if (pdfResizeOutputNameInput) {
          const baseNameNoExt = getFilenameWithoutExtension(selectedFilePath);
          const suffix = getOutputSuffixForPdfResize(); // Use new function
          const newOutputName = `${baseNameNoExt}${suffix}`; // No .pdf here
          pdfResizeOutputNameInput.value = newOutputName;
          // Trigger input event for live validation and settings saving
          const inputEvent = new Event('input', { bubbles: true });
          pdfResizeOutputNameInput.dispatchEvent(inputEvent);
        }

        const saveResult = await window.electronAPI.saveSettings(appSettings); // Save other settings like selected path
        if (!saveResult || !saveResult.success) {
          console.error('Failed to save settings after PDF Resize file selection:', saveResult ? saveResult.error : 'Unknown error');
          showToast('警告：无法保存文件选择设置。', 'warning');
        }
      }
      // If newPath is null (cancelled), selectedFilePath might still hold the previous value.
      // The UI update for "未选择文件" is handled by updateFileSelectionUI if selectedFilePath becomes empty.
      // If user cancels, and selectedFilePath was already empty, updateFileSelectionUI will show "未选择文件".
      // If user cancels, and selectedFilePath had a value, it will still show that old file's info
      // unless we explicitly clear selectedFilePath here on cancel.
      // For now, let's assume cancelling means "keep the last valid selection or show '未选择文件' if none".
      // The error clearing logic for the button itself is handled above if a new file is successfully processed.
    })

    // Initialize the badge state on load - this will be handled by loadAndApplySettings
    // const initialSelectedFileElement = document.getElementById('selectedFile');
    // if (!selectedFilePath) {
    //     initialSelectedFileElement.textContent = '未选择文件';
    //     initialSelectedFileElement.classList.remove('file-selected-badge');
    // }


    // Function to update PDF resize output name based on current selections
    function updatePdfResizeOutputNameBasedOnSelections() {
      if (selectedFilePath) { // Only update if a file is selected
        const pdfResizeOutputNameInput = document.getElementById('pdfResizeOutputName');
        if (pdfResizeOutputNameInput) {
          const baseNameNoExt = getFilenameWithoutExtension(selectedFilePath);
          const suffix = getOutputSuffixForPdfResize();
          const newOutputName = `${baseNameNoExt}${suffix}`;
          pdfResizeOutputNameInput.value = newOutputName;
          // Trigger input event for live validation and settings saving
          const inputEvent = new Event('input', { bubbles: true });
          pdfResizeOutputNameInput.dispatchEvent(inputEvent);
        }
      }
    }

    document.getElementById('pageSize').addEventListener('change', async function() { // Added async
      const customSizeEl = document.getElementById('customSize');
      if (this.value === 'custom') {
        customSizeEl.style.display = 'flex'; // Ensure it's flex for layout
      } else {
        customSizeEl.style.display = 'none';
      }
      appSettings.pageSize = this.value;
      await window.electronAPI.saveSettings(appSettings);
      updatePdfResizeOutputNameBasedOnSelections(); // Update output name on page size change
    })
    // Ensure sheinOutputCustomSize is flex by default if it's always visible
    // Or add a similar JS logic if it needs to be toggled. For now, CSS will handle it.

    // Add event listeners to custom dimension inputs for PDF Resize
    const customWidthInput = document.getElementById('customWidth');
    const customHeightInput = document.getElementById('customHeight');
    const customWidthErrorEl = document.getElementById('customWidthError');
    const customHeightErrorEl = document.getElementById('customHeightError');

    if (customWidthInput && customWidthErrorEl) {
      customWidthInput.addEventListener('input', () => {
        const widthVal = parseFloat(customWidthInput.value);
        if (!isNaN(widthVal) && widthVal > 0) {
          customWidthInput.classList.remove('input-error');
          customWidthErrorEl.textContent = '';
          customWidthErrorEl.style.display = 'none';
        }
        updatePdfResizeOutputNameBasedOnSelections(); // Update output name on custom width change
      });
   }

   if (customHeightInput && customHeightErrorEl) {
     customHeightInput.addEventListener('input', () => {
       const heightVal = parseFloat(customHeightInput.value);
       if (!isNaN(heightVal) && heightVal > 0) {
         customHeightInput.classList.remove('input-error');
         customHeightErrorEl.textContent = '';
         customHeightErrorEl.style.display = 'none';
       }
       updatePdfResizeOutputNameBasedOnSelections(); // Update output name on custom height change
     });
   }

    // Add input event listener for pdfResizeOutputName to clear error on valid input
    const pdfResizeOutputNameInputForLiveValidation = document.getElementById('pdfResizeOutputName');
    if (pdfResizeOutputNameInputForLiveValidation) {
      pdfResizeOutputNameInputForLiveValidation.addEventListener('input', function() {
        // Construct a temporary full filename if it doesn't end with .pdf for validation purposes
        let tempOutputName = this.value.trim();
        if (tempOutputName && !tempOutputName.toLowerCase().endsWith('.pdf')) {
          // We don't append .pdf here for live validation,
          // as the user might be typing the extension or it might be optional until submission.
          // The main validation on submit handles adding .pdf if missing.
          // isValidFilename should handle names with or without extensions correctly.
        }
        const validation = isValidFilename(tempOutputName);
        if (validation.valid) {
          this.classList.remove('input-error');
        }
        // We don't add 'input-error' here, as that's handled on submit.
        // This listener is only for clearing the error.
      });
    }

    document.getElementById('processBtn').addEventListener('click', async () => {
      const processButton = document.getElementById('processBtn');
      const clearPdfResizeFormBtn = document.getElementById('clearPdfResizeFormBtn'); // Get clear button
      const originalButtonText = processButton.textContent;
      let timerInterval; // Declare timerInterval outside try block

      if (clearPdfResizeFormBtn) clearPdfResizeFormBtn.disabled = true; // Disable clear button

      try {
        // Resetting file selection error state (done after global resultDiv reset and before other specific resets)
        // This will be handled by the more general reset block below.

        if (!selectedFilePath) {
        const openFileButton = document.getElementById('openFile');
        const selectedFileErrorEl = document.getElementById('selectedFileError');

        if (openFileButton) {
            openFileButton.classList.add('input-error');
            // Optionally focus the button, though it might be disruptive
            // openFileButton.focus();
        }
        const errorMessage = currentTranslations.errorSelectPdfFile || '请先选择一个 PDF 文件。';
        showToast(errorMessage, 'error'); // Added toast notification
        if (selectedFileErrorEl) {
            selectedFileErrorEl.textContent = errorMessage;
            selectedFileErrorEl.style.display = 'block';
        } else {
            // Fallback if the error element itself is somehow missing
            console.error("PDF Resize Error: selectedFileError element not found in DOM!");
            // Toast already shown, so no need for resultDiv fallback for this specific message
        }
        // Ensure button is reset if validation fails early
        if (processButton) {
            processButton.disabled = false;
            processButton.textContent = originalButtonText;
            processButton.classList.remove('processing');
        }
        // No timer should be active here yet, but good practice if logic changes
        if (timerInterval) clearInterval(timerInterval);
        return;
      }
 
      const operations = {}
      const pdfResizeOutputNameInput = document.getElementById('pdfResizeOutputName');

      // Reset/hide post-process actions for pdfResizeView at the start of processing
      // if (pdfResizePostProcessActionsDiv) { // No longer using the static postProcessActionsDiv
      //     pdfResizePostProcessActionsDiv.style.display = 'none';
      // }
      // currentGeneratedPdfResizePath = ''; // Path will be local to each result entry
      const resultDivForReset = document.getElementById('result'); // Global result div
      // We don't clear the entire resultDiv anymore. New results are prepended.
      // if (resultDivForReset) {
      //     resultDivForReset.innerHTML = '';
      //     resultDivForReset.className = '';
      //     resultDivForReset.style.display = 'none';
      // }
      // Also reset custom dimension inline errors here if they were shown from a previous attempt
      const widthInputForReset = document.getElementById('customWidth');
      const heightInputForReset = document.getElementById('customHeight');
      const customWidthErrorElForReset = document.getElementById('customWidthError');
      const customHeightErrorElForReset = document.getElementById('customHeightError');

      if (widthInputForReset && customWidthErrorElForReset) {
          widthInputForReset.classList.remove('input-error');
          customWidthErrorElForReset.textContent = '';
          customWidthErrorElForReset.style.display = 'none';
      }
      if (heightInputForReset && customHeightErrorElForReset) {
          heightInputForReset.classList.remove('input-error');
          customHeightErrorElForReset.textContent = '';
          customHeightErrorElForReset.style.display = 'none';
      }
      // Also reset file selection error state here
      const openFileButtonForReset = document.getElementById('openFile');
      const selectedFileErrorForReset = document.getElementById('selectedFileError');
      if (openFileButtonForReset && selectedFileErrorForReset) {
          openFileButtonForReset.classList.remove('input-error');
          selectedFileErrorForReset.textContent = '';
          selectedFileErrorForReset.style.display = 'none';
      }

      // getCurrentHHMMSS is now a global helper function

      let outputName = pdfResizeOutputNameInput.value.trim();
      // Auto-generation of outputName if empty is now handled by file selection,
      // but keep this as a fallback if user clears it and then clicks process.
      if (!outputName) {
        const base = selectedFilePath ? getFilenameWithoutExtension(selectedFilePath) : 'resized_file';
        const suffix = selectedFilePath ? getOutputSuffixForPdfResize() : `_${getCurrentHHMMSS()}`; // Fallback suffix if no file selected
        outputName = `${base}${suffix}`; // No .pdf here
        // pdfResizeOutputNameInput.value = outputName; // Optionally update the input if it was empty
      }

      // Validate the name part without .pdf
      const filenameValidation = isValidFilename(outputName);
      if (!filenameValidation.valid) {
        showToast(filenameValidation.message, 'error');
        // Optionally, highlight the input field
        if (pdfResizeOutputNameInput) {
          pdfResizeOutputNameInput.classList.add('input-error');
          pdfResizeOutputNameInput.focus();
        }
        // Restore button state if validation fails before processing starts
        if (processButton) {
            processButton.disabled = false;
            processButton.textContent = originalButtonText;
            processButton.classList.remove('processing');
        }
        // timerInterval should be cleared here as per the logic
        if (timerInterval) clearInterval(timerInterval);
        return;
      }
      
      // 获取尺寸参数
      const sizeType = document.getElementById('pageSize').value
      if (sizeType !== 'custom') {
        operations.resize = pageSizeMap[sizeType]
      } else {
        const widthInput = document.getElementById('customWidth');
        const heightInput = document.getElementById('customHeight');
        const customWidthErrorEl = document.getElementById('customWidthError');
        const customHeightErrorEl = document.getElementById('customHeightError');

        let validationPassed = true;
        let width = NaN;
        let height = NaN;

        if (widthInput) {
            width = parseFloat(widthInput.value);
        } else {
            console.error("PDF Resize Error: customWidth input element not found in DOM.");
            validationPassed = false; // Critical element missing
        }

        if (heightInput) {
            height = parseFloat(heightInput.value);
        } else {
            console.error("PDF Resize Error: customHeight input element not found in DOM.");
            validationPassed = false; // Critical element missing
        }
        
        // Proceed with validation only if critical elements were found for parsing
        if (validationPassed) {
            console.log(`Initial validation for width: ${width}, height: ${height}`);
            if (isNaN(width) || width <= 0) {
                console.log(`Width validation failed. Value: ${width}`);
                if (widthInput) {
                    console.log(`Attempting to style widthInput (ID: ${widthInput.id}). Current background: ${widthInput.style.backgroundColor}, Classes: ${widthInput.className}`);
                    heightInput.classList.add('input-error');
                    widthInput.classList.add('input-error');
                    console.log(`After styling widthInput. New background: ${widthInput.style.backgroundColor}, New classes: ${widthInput.className}`);
                    widthInput.focus();
                }
                const widthErrorMessage = currentTranslations.errorInvalidWidth || '宽度必须是有效的正数。';
                showToast(widthErrorMessage, 'error');
                if (customWidthErrorEl) {
                    console.log(`Attempting to show customWidthErrorEl (ID: ${customWidthErrorEl.id}). Current display: ${customWidthErrorEl.style.display}`);
                    customWidthErrorEl.textContent = widthErrorMessage;
                    customWidthErrorEl.style.display = 'block';
                    console.log(`After showing customWidthErrorEl. New display: ${customWidthErrorEl.style.display}, Text: ${customWidthErrorEl.textContent}`);
                } else {
                    console.error("PDF Resize Error: customWidthError element not found for displaying message.");
                }
                validationPassed = false;
                console.log(`Set validationPassed to false due to invalid width.`);
            }

            if (isNaN(height) || height <= 0) {
                console.log(`Height validation failed. Value: ${height}`);
                if (heightInput) {
                    console.log(`Attempting to style heightInput (ID: ${heightInput.id}). Current background: ${heightInput.style.backgroundColor}, Classes: ${heightInput.className}`);
                    widthInput.classList.add('input-error'); // Diagnostic style change
                    heightInput.classList.add('input-error');
                    console.log(`After styling heightInput. New background: ${heightInput.style.backgroundColor}, New classes: ${heightInput.className}`);
                    if (validationPassed && widthInput) {
                        heightInput.focus();
                    } else if (!widthInput && heightInput) {
                        heightInput.focus();
                    } else if (heightInput && !widthInput) { // If width was invalid but widthInput itself was missing
                        heightInput.focus();
                    } else if (validationPassed && !widthInput) { // If width was considered valid (e.g. not NaN) but widthInput was missing
                         heightInput.focus(); // Focus height if it's the first actual input field with an error
                    } else if (!validationPassed && heightInput) { // If width validation failed, and now height is also failing
                        // Let width keep focus if it was set, otherwise focus height if widthInput was missing
                        if(document.activeElement !== widthInput) heightInput.focus();
                    }


                }
                const heightErrorMessage = currentTranslations.errorInvalidHeight || '高度必须是有效的正数。';
                showToast(heightErrorMessage, 'error');
                if (customHeightErrorEl) {
                    console.log(`Attempting to show customHeightErrorEl (ID: ${customHeightErrorEl.id}). Current display: ${customHeightErrorEl.style.display}`);
                    customHeightErrorEl.textContent = heightErrorMessage;
                    customHeightErrorEl.style.display = 'block';
                    console.log(`After showing customHeightErrorEl. New display: ${customHeightErrorEl.style.display}, Text: ${customHeightErrorEl.textContent}`);
                } else {
                    console.error("PDF Resize Error: customHeightError element not found for displaying message.");
                }
                validationPassed = false;
                console.log(`Set validationPassed to false due to invalid height.`);
            }
        }

        console.log(`Final validationPassed state before return check: ${validationPassed}`);
        if (!validationPassed) {
          console.log("Validation failed (or critical elements missing), returning early from processBtn.");
          // Ensure button is reset if validation fails here
          if (processButton) {
              processButton.disabled = false;
              processButton.textContent = originalButtonText;
              processButton.classList.remove('processing');
          }
          if (timerInterval) clearInterval(timerInterval); // Clear timer if it started before this point
          return; // Stop if elements are missing or validation fails
        }
        console.log("Validation passed, proceeding to operations.resize.");

        // If we reach here, all elements were found and validation passed
        operations.resize = {
          width: width * 2.835, // width and height are guaranteed to be valid numbers here
          height: height * 2.835
        }
      }
      // --- Show Processing State ---
      let startTime = 0;
      // timerInterval is already declared in the outer scope (line 523)
      // processButton and originalButtonText are defined at the start of the event listener
      if (processButton) {
        processButton.disabled = true;
        startTime = Date.now();
        let secondsElapsed = 0;
        processButton.textContent = (currentTranslations.processing || '正在处理中... ({seconds}秒)').replace('{seconds}', secondsElapsed);
        processButton.classList.add('processing'); // Add processing class
        timerInterval = setInterval(() => {
          secondsElapsed++;
          processButton.textContent = (currentTranslations.processing || '正在处理中... ({seconds}秒)').replace('{seconds}', secondsElapsed);
        }, 1000);
      }
      // Optional: Show a processing message in resultDiv
      // const resultDivForProcessing = document.getElementById('result');
      // if (resultDivForProcessing) {
      //   resultDivForProcessing.innerHTML = '<p>正在处理，请稍候...</p>';
      //   resultDivForProcessing.className = 'info'; // Needs a .info style in CSS
      //   resultDivForProcessing.style.display = 'block';
      // }
      // --- End Show Processing State ---

      const finalOutputNameWithPdf = outputName.toLowerCase().endsWith('.pdf') ? outputName : outputName + '.pdf';
      console.log('[PDF Resize] Before calling window.electronAPI.processPDF. Params:', { filePath: selectedFilePath, operations, outputName: finalOutputNameWithPdf }); // DEBUG LOG
      const apiResult = await window.electronAPI.processPDF({ // Renamed to apiResult
        filePath: selectedFilePath,
        operations,
        outputName: finalOutputNameWithPdf, // Pass name with .pdf
        outputDir: appSettings.outputDirectory || ''
      });
      console.log('[PDF Resize] After calling window.electronAPI.processPDF. Result:', apiResult); // DEBUG LOG

      const endTime = Date.now();
      const totalTimeSeconds = ((endTime - startTime) / 1000).toFixed(2);
      const resultDiv = document.getElementById('result');
      const generatedPath = (apiResult && apiResult.success) ? apiResult.path : null;

      const entryDiv = document.createElement('div');
      entryDiv.className = 'result-entry'; // Base class
      let entryHtml = '';

      if (apiResult && apiResult.success && generatedPath) {
        showToast(currentTranslations.processingSuccess || '处理成功！', 'success');
        entryDiv.classList.add('success-entry'); // Use new specific success class
        entryHtml = `<p><strong>${currentTranslations.processingStatusSuccess || '处理成功'}</strong></p><p>${(currentTranslations.savePath || '保存路径：{path}').replace('{path}', generatedPath)}</p>`;
        if (apiResult.outputFileSize !== null && apiResult.outputFileSize !== undefined) {
          let sizeAndPages = `${(currentTranslations.fileSize || '文件大小：{size}').replace('{size}', formatBytes(apiResult.outputFileSize))}`;
          if (apiResult.outputPageCount !== null && apiResult.outputPageCount !== undefined) {
            sizeAndPages += `，${(currentTranslations.pageCount || '页数：{count}').replace('{count}', apiResult.outputPageCount)}`;
          }
          entryHtml += `<p>${sizeAndPages}</p>`;
        } else if (apiResult.outputPageCount !== null && apiResult.outputPageCount !== undefined) {
          entryHtml += `<p>${(currentTranslations.pageCount || '页数：{count}').replace('{count}', apiResult.outputPageCount)}</p>`;
        }
        if(apiResult.metadataError){
            entryHtml += `<p style="color: orange;">${(currentTranslations.warningOutputMetadata || '输出文件元数据警告: {error}').replace('{error}', apiResult.metadataError)}</p>`;
        }
      } else {
        entryDiv.classList.add('error-entry'); // Use new specific error class
        const errorMessage = (apiResult && apiResult.error) ? apiResult.error : (currentTranslations.unknownProcessingError || '未知处理错误。');
        showToast((currentTranslations.pdfResizeFailed || 'PDF尺寸调整失败：{error}').replace('{error}', errorMessage), 'error');
        entryHtml = `<p class="error-message-text"><strong>${currentTranslations.processingStatusFailed || '处理失败：'}</strong>${errorMessage}</p>`; // Add class to error message paragraph
      }

      const startTimeFormatted = new Date(startTime).toLocaleString('zh-CN', { year: 'numeric', month: '2-digit', day: '2-digit', hour: '2-digit', minute: '2-digit', second: '2-digit', hour12: false });
      entryHtml += `<p>${(currentTranslations.processingStartTime || '处理开始时间：{time}').replace('{time}', startTimeFormatted)}</p>`;
      entryHtml += `<p>${(currentTranslations.totalTime || '总耗时：{seconds}秒').replace('{seconds}', totalTimeSeconds)}</p>`;
      entryDiv.innerHTML = entryHtml;

      // Create and append action buttons for this entry
      const actionsDiv = document.createElement('div');
      actionsDiv.className = 'action-buttons-container'; // Use new class for button container

      const openBtn = document.createElement('button');
      openBtn.textContent = currentTranslations.openFile || '打开文件';
      openBtn.className = 'action-button action-button-primary'; // Primary action
      if (!generatedPath) openBtn.disabled = true;
      openBtn.addEventListener('click', async () => {
        if (generatedPath) {
          try { await window.electronAPI.openPath(generatedPath); }
          catch (err) { showToast(`无法打开文件: ${err.message}`, 'error'); }
        }
      });
      actionsDiv.appendChild(openBtn);

      const showInFolderBtn = document.createElement('button');
      showInFolderBtn.textContent = currentTranslations.openFolder || '打开文件夹';
      showInFolderBtn.className = 'action-button';
      if (!generatedPath) showInFolderBtn.disabled = true;
      showInFolderBtn.addEventListener('click', async () => {
        if (generatedPath) {
          try { await window.electronAPI.showItemInFolder(generatedPath); }
          catch (err) { showToast(`无法在文件夹中显示: ${err.message}`, 'error'); }
        }
      });
      actionsDiv.appendChild(showInFolderBtn);

      const copyBtn = document.createElement('button');
      copyBtn.textContent = currentTranslations.copyFile || '复制文件';
      copyBtn.className = 'action-button';
      copyBtn.title = currentTranslations.copyFileTooltip || '尝试复制文件到剪贴板 (若失败则复制路径)';
      if (!generatedPath) copyBtn.disabled = true;
      copyBtn.addEventListener('click', async () => {
        if (generatedPath) {
          try {
            const copyResult = await window.electronAPI.copyFileToClipboard(generatedPath);
            if (copyResult && copyResult.success) {
              showToast(copyResult.action === 'path_copied_unexpected_fallback' ? (copyResult.message || '未能复制文件本身，已改为复制文件路径至剪贴板。') : '文件已复制到剪贴板！', copyResult.action === 'path_copied_unexpected_fallback' ? 'warning' : 'success');
            } else {
              showToast(`复制文件失败: ${(copyResult && copyResult.error) ? copyResult.error : '未知错误'}`, 'error');
            }
          } catch (err) { showToast(`复制操作出错: ${err.message}`, 'error'); }
        }
      });
      actionsDiv.appendChild(copyBtn);
      entryDiv.appendChild(actionsDiv);

      if (resultDiv) {
        resultDiv.prepend(entryDiv);
        resultDiv.style.display = 'block';
      }

    } catch (error) {
      console.error('[PDF Resize] Error in processBtn click handler:', error);
      const endTime = Date.now(); // Recalculate endTime for catch block
      const totalTimeSeconds = ((endTime - startTime) / 1000).toFixed(2); // Recalculate totalTimeSeconds
      
      const errorEntryDiv = document.createElement('div');
      errorEntryDiv.className = 'result-entry error-entry'; // Add new specific error class
      let errorHtml = `<p class="error-message-text"><strong>${currentTranslations.clientError || '客户端错误：'}</strong>${error.message || (currentTranslations.unexpectedClientError || '发生意外错误。')}</p>`; // Add class to error message paragraph
      const startTimeFormatted = new Date(startTime).toLocaleString('zh-CN', { year: 'numeric', month: '2-digit', day: '2-digit', hour: '2-digit', minute: '2-digit', second: '2-digit', hour12: false });
      errorHtml += `<p>${(currentTranslations.processingStartTime || '处理开始时间：{time}').replace('{time}', startTimeFormatted)}</p>`;
      errorHtml += `<p>${(currentTranslations.totalTime || '总耗时：{seconds}秒').replace('{seconds}', totalTimeSeconds)}</p>`;
      errorEntryDiv.innerHTML = errorHtml;
      
      // Add disabled action buttons for client errors as well for consistency
      const errorActionsDiv = document.createElement('div');
      errorActionsDiv.className = 'action-buttons-container'; // Use new class for button container
      ['打开文件', '打开文件夹', '复制文件'].forEach((text, index) => {
          const btn = document.createElement('button');
          btn.textContent = text;
          // Apply primary style to "打开文件"
          btn.className = (index === 0) ? 'action-button action-button-primary' : 'action-button';
          btn.disabled = true;
          errorActionsDiv.appendChild(btn);
      });
      errorEntryDiv.appendChild(errorActionsDiv);

      const resultDivForError = document.getElementById('result');
      if (resultDivForError) {
        resultDivForError.prepend(errorEntryDiv);
        resultDivForError.style.display = 'block';
      }
      showToast(`PDF尺寸调整出错：${error.message || '发生意外错误。'}`, 'error');
    } finally {
      // --- Reset Processing State ---
      if (timerInterval) clearInterval(timerInterval);
      // processButton and originalButtonText are defined at the start of the event listener
      if (processButton) {
          processButton.disabled = false;
          processButton.textContent = originalButtonText;
          processButton.classList.remove('processing'); // Remove processing class
      }
      if (clearPdfResizeFormBtn) clearPdfResizeFormBtn.disabled = false; // Re-enable clear button
      // If resultDiv was used for a "processing..." message and not overwritten by success/failure,
      // it might need clearing here. However, current logic for success/failure does update resultDiv or hides it.
    }
    })

    // PDF Resize View - Clear Form Button
    const clearPdfResizeFormBtn = document.getElementById('clearPdfResizeFormBtn');
    if (clearPdfResizeFormBtn) {
      clearPdfResizeFormBtn.addEventListener('click', async () => {
        // Clear file selection
        selectedFilePath = '';
        updateFileSelectionUI(selectedFilePath, 'selectedFile', null, null); // Pass nulls for metadata
        appSettings.pdfResizeSelectedPath = '';
        const openFileButton = document.getElementById('openFile');
        const selectedFileErrorEl = document.getElementById('selectedFileError');
        if (openFileButton) openFileButton.classList.remove('input-error');
        if (selectedFileErrorEl) {
          selectedFileErrorEl.textContent = '';
          selectedFileErrorEl.style.display = 'none';
        }

        // Clear output name
        const pdfResizeOutputNameInput = document.getElementById('pdfResizeOutputName');
        if (pdfResizeOutputNameInput) pdfResizeOutputNameInput.value = '';
        appSettings.pdfResizeOutputName = '';

        // Reset page size
        const pageSizeSelect = document.getElementById('pageSize');
        if (pageSizeSelect) pageSizeSelect.value = 'Shein'; // Default to Shein
        appSettings.pageSize = 'Shein';
        const customSizeEl = document.getElementById('customSize');
        if (customSizeEl) customSizeEl.style.display = 'none';
        
        // Clear custom dimensions and their errors
        const customWidthInput = document.getElementById('customWidth');
        const customHeightInput = document.getElementById('customHeight');
        const customWidthErrorEl = document.getElementById('customWidthError');
        const customHeightErrorEl = document.getElementById('customHeightError');
        if (customWidthInput) {
          customWidthInput.value = '';
          customWidthInput.classList.remove('input-error');
        }
        if (customWidthErrorEl) {
          customWidthErrorEl.textContent = '';
          customWidthErrorEl.style.display = 'none';
        }
        appSettings.customWidth = '';

        if (customHeightInput) {
          customHeightInput.value = '';
          customHeightInput.classList.remove('input-error');
        }
        if (customHeightErrorEl) {
          customHeightErrorEl.textContent = '';
          customHeightErrorEl.style.display = 'none';
        }
        appSettings.customHeight = '';

        // Clear result and post-process actions
        const resultDiv = document.getElementById('result');
        if (resultDiv) {
          resultDiv.innerHTML = ''; // Clear all dynamically added entries
          resultDiv.className = '';
          resultDiv.style.display = 'none';
        }
        // if (pdfResizePostProcessActionsDiv) { // No longer used
        //   pdfResizePostProcessActionsDiv.style.display = 'none';
        // }
        // currentGeneratedPdfResizePath = ''; // No longer used

        // Clear output directory
        appSettings.outputDirectory = '';
        const defaultDirText = currentTranslations.notSetUseDefault || '未设置，使用源文件目录';
        document.getElementById('outputDirDisplay').textContent = defaultDirText;
        document.getElementById('sheinOutputDirDisplay').textContent = defaultDirText;

        await window.electronAPI.saveSettings(appSettings);
        showToast(currentTranslations['toast.pdfResizeFormCleared'] || 'PDF 尺寸调整已清空', 'info');
      });
    }

    // Event listeners for PDF Resize Post-Process Actions are now created dynamically per entry
    // So, the static listeners below are no longer needed for pdfResizePostProcessActionsDiv
    // if (pdfResizeOpenGeneratedFileBtn) { ... }
    // if (pdfResizeShowGeneratedFileInFolderBtn) { ... }
    // if (pdfResizeCopyFileBtn) { ... }

    // --- Shein 标签 Feature ---
    let selectedSheinPdf1Path = '';
    let selectedSheinPdf2Path = '';

    const sheinOpenFile1Btn = document.getElementById('sheinOpenFile1Btn');
    const sheinSelectedFile1Element = document.getElementById('sheinSelectedFile1');
    const sheinOpenFile2Btn = document.getElementById('sheinOpenFile2Btn');
    const sheinSelectedFile2Element = document.getElementById('sheinSelectedFile2');
    const generateSheinLabelBtn = document.getElementById('generateSheinLabelBtn');
    const sheinResultDiv = document.getElementById('sheinResult');
    const sheinOutputNameInput = document.getElementById('sheinOutputName');
    const sheinOutputPageSizeSelect = document.getElementById('sheinOutputPageSize'); // New select
    const sheinOutputCustomDimensionsDiv = document.getElementById('sheinOutputCustomDimensions'); // New div for custom inputs
    const sheinOutputWidthInput = document.getElementById('sheinOutputWidth'); // Existing input, now inside new div
    const sheinOutputHeightInput = document.getElementById('sheinOutputHeight'); // Existing input, now inside new div
    const sheinPostProcessActionsDiv = document.getElementById('sheinPostProcessActions');
    const openGeneratedFileBtn = document.getElementById('openGeneratedFileBtn'); // Note: These are generic IDs, ensure they are scoped correctly or made specific
    const showGeneratedFileInFolderBtn = document.getElementById('showGeneratedFileInFolderBtn'); // Same as above
    const sheinCopyFileBtn = document.getElementById('sheinCopyFileBtn'); // New button for Shein copy
    let currentGeneratedSheinLabelPath = ''; // To store the path for the buttons

   function updateSheinEditorAreaSize() {
       const pageSize = sheinOutputPageSizeSelect.value;
       let widthMM, heightMM;

       if (pageSize === 'custom') {
           widthMM = parseFloat(sheinOutputWidthInput.value) || 70;
           heightMM = parseFloat(sheinOutputHeightInput.value) || 60;
       } else {
           const dims = pageSizeMapMM[pageSize];
           widthMM = dims.width;
           heightMM = dims.height;
       }

       const editorArea = document.getElementById('shein-editor-area');
       editorArea.style.width = '100%';
       const displayWidth = editorArea.clientWidth;
       
       if (displayWidth > 0 && heightMM > 0) {
           const aspectRatio = widthMM / heightMM;
           editorArea.style.height = `${displayWidth / aspectRatio}px`;
       } else {
           editorArea.style.height = '250px'; // Fallback height
       }
   }

   function setupInteractForElement(element) {
       if (!element) return;

       // Unset previous interactable instance to apply new settings cleanly
       interact(element).unset();

       const keepAspectRatioCheckbox = document.getElementById('sheinKeepAspectRatio');

       interact(element)
           .draggable({
               listeners: {
                   move(event) {
                       let x = (parseFloat(event.target.dataset.x) || 0) + event.dx;
                       let y = (parseFloat(event.target.dataset.y) || 0) + event.dy;

                       event.target.style.transform = `translate(${x}px, ${y}px)`;
                       
                       Object.assign(event.target.dataset, { x, y });
                   },
                   end: function (event) {
                       saveEditorLayout();
                   },
               },
               modifiers: [
                   interact.modifiers.restrictRect({
                       restriction: 'parent'
                   })
               ]
           })
           .resizable({
               edges: { left: true, right: true, bottom: true, top: true },
               listeners: {
                   move(event) {
                       let x = (parseFloat(event.target.dataset.x) || 0);
                       let y = (parseFloat(event.target.dataset.y) || 0);

                       event.target.style.width = `${event.rect.width}px`;
                       event.target.style.height = `${event.rect.height}px`;

                       x += event.deltaRect.left;
                       y += event.deltaRect.top;

                       event.target.style.transform = `translate(${x}px, ${y}px)`;

                       Object.assign(event.target.dataset, { x, y });
                   },
                   end: function (event) {
                       saveEditorLayout();
                   },
               },
               modifiers: [
                   interact.modifiers.restrictEdges({
                       outer: 'parent'
                   }),
                   interact.modifiers.restrictSize({
                       min: { width: 50, height: 50 }
                   }),
                   ...(keepAspectRatioCheckbox && keepAspectRatioCheckbox.checked ? [interact.modifiers.aspectRatio({ ratio: 'preserve' })] : [])
               ],
               inertia: true
           });
   }

   function applySheinLayoutTemplate() {
       const editorArea = document.getElementById('shein-editor-area');
       const barcodeEl = document.getElementById('shein-pdf-2'); // Barcode PDF
       const ecRepEl = document.getElementById('shein-pdf-1');   // EC Rep PDF

       // Only apply template if both elements are present in the editor
       if (!editorArea || !barcodeEl || !ecRepEl) {
           return;
       }

       const template = 'barcode-top-ec-bottom'; // Hardcoded default template
       const editorWidth = editorArea.clientWidth;
       const editorHeight = editorArea.clientHeight;
       
       const verticalPadding = 5; // 5px from top/bottom edge
       const horizontalPaddingPercent = 0.05; // 5% padding on sides

       if (template === 'barcode-top-ec-bottom') {
           // --- Barcode (Top) ---
           const barcodeAspectRatio = parseFloat(barcodeEl.dataset.aspectRatio);
           if (!isNaN(barcodeAspectRatio) && barcodeAspectRatio > 0) {
               const barcodeWidth = editorWidth * (1 - 2 * horizontalPaddingPercent);
               const barcodeHeight = barcodeWidth / barcodeAspectRatio;
               barcodeEl.style.width = `${barcodeWidth}px`;
               barcodeEl.style.height = `${barcodeHeight}px`;
               
               const barcodeX = (editorWidth - barcodeWidth) / 2; // Center horizontally
               const barcodeY = verticalPadding; // Place at the top with padding
               
               barcodeEl.style.transform = `translate(${barcodeX}px, ${barcodeY}px)`;
               Object.assign(barcodeEl.dataset, { x: barcodeX, y: barcodeY });
           }

           // --- EC Rep (Bottom) ---
           const ecRepAspectRatio = parseFloat(ecRepEl.dataset.aspectRatio);
           if (!isNaN(ecRepAspectRatio) && ecRepAspectRatio > 0) {
               const ecRepWidth = editorWidth * (1 - 2 * horizontalPaddingPercent);
               const ecRepHeight = ecRepWidth / ecRepAspectRatio;
               ecRepEl.style.width = `${ecRepWidth}px`;
               ecRepEl.style.height = `${ecRepHeight}px`;

               const ecRepX = (editorWidth - ecRepWidth) / 2; // Center horizontally
               const ecRepY = editorHeight - ecRepHeight - verticalPadding; // Place at the bottom with padding
               
               ecRepEl.style.transform = `translate(${ecRepX}px, ${ecRepY}px)`;
               Object.assign(ecRepEl.dataset, { x: ecRepX, y: ecRepY });
           }
       }
       // Future templates can be added here with 'else if'
   }

   async function saveEditorLayout() {
       const editorArea = document.getElementById('shein-editor-area');
       if (!editorArea) return;

       const layoutData = [];
       editorArea.querySelectorAll('.draggable-pdf-page').forEach(el => {
           layoutData.push({
               id: el.id,
               x: el.dataset.x || '0',
               y: el.dataset.y || '0',
               width: el.style.width,
               height: el.style.height,
           });
       });

       appSettings.sheinEditorLayout = layoutData;
       await window.electronAPI.saveSettings(appSettings);
   }

   function applySavedLayout() {
       if (appSettings.sheinEditorLayout && Array.isArray(appSettings.sheinEditorLayout)) {
           appSettings.sheinEditorLayout.forEach(item => {
               const element = document.getElementById(item.id);
               if (element) {
                   element.style.width = item.width;
                   element.style.height = item.height;
                   const x = parseFloat(item.x) || 0;
                   const y = parseFloat(item.y) || 0;
                   element.style.transform = `translate(${x}px, ${y}px)`;
                   element.dataset.x = x;
                   element.dataset.y = y;
               }
           });
       }
   }

   async function renderPdfPageToEditor(filePath, elementId, displayName) {
       const editorArea = document.getElementById('shein-editor-area');
       let element = document.getElementById(elementId);
       if (element) {
           editorArea.removeChild(element);
       }

       try {
           const pdf = await pdfjsLib.getDocument(filePath).promise;
           const page = await pdf.getPage(1);
           const viewport = page.getViewport({ scale: 1.0 }); // Use scale 1.0 to get original ratio

           const canvas = document.createElement('canvas');
           const context = canvas.getContext('2d');
           canvas.height = viewport.height;
           canvas.width = viewport.width;

           await page.render({ canvasContext: context, viewport: viewport }).promise;

           element = document.createElement('div');
           element.id = elementId;
           element.className = 'draggable-pdf-page';
           element.style.backgroundImage = `url(${canvas.toDataURL()})`;
           
           // Set initial size to 50% of editor width, maintaining aspect ratio
           const editorWidth = editorArea.clientWidth;
           const aspectRatio = viewport.width / viewport.height;
           const initialWidth = editorWidth * 0.5;
           const initialHeight = initialWidth / aspectRatio;

           element.style.width = `${initialWidth}px`;
           element.style.height = `${initialHeight}px`;
           element.dataset.pdfPath = filePath;
           element.dataset.displayName = displayName;
           element.dataset.aspectRatio = aspectRatio;

           editorArea.appendChild(element);
           setupInteractForElement(element);

           // Attempt to apply layout template automatically if both PDFs are now present
           applySheinLayoutTemplate();

       } catch (error) {
           console.error(`Error rendering PDF ${displayName}:`, error);
           showToast(`渲染PDF失败: ${displayName}`, 'error');
       }
   }

    // Logic for Shein output page size selection
    if (sheinOutputPageSizeSelect) {
      sheinOutputPageSizeSelect.addEventListener('change', async function() { // Added async
        if (this.value === 'custom') {
          sheinOutputCustomDimensionsDiv.style.display = 'flex';
        } else {
          sheinOutputCustomDimensionsDiv.style.display = 'none';
          const selectedSizeMM = pageSizeMapMM[this.value];
          if (selectedSizeMM) {
            sheinOutputWidthInput.value = selectedSizeMM.width;
            sheinOutputHeightInput.value = selectedSizeMM.height;
          }
        }
        updateSheinEditorAreaSize();
        appSettings.sheinOutputPageSize = this.value;
        await window.electronAPI.saveSettings(appSettings);
      });
      // Trigger change on load to set initial state based on default "Shein" selection
      // This will hide custom inputs and ensure width/height inputs are 70/60
      // (though HTML value attributes already set them, this ensures consistency if default changes)
      // This logic will be handled by the general form loading logic later
    }

    // Old default dimension setting for Shein 标签 (lines 443-448) is now removed
    // as it's handled by the select logic and HTML value attributes.

    // Add event listeners to custom dimension inputs for Shein 标签 to clear errors on valid input
    const sheinOutputWidthErrorEl = document.getElementById('sheinOutputWidthError'); // Already got this for validation
    const sheinOutputHeightErrorEl = document.getElementById('sheinOutputHeightError'); // Already got this for validation

    if (sheinOutputWidthInput && sheinOutputWidthErrorEl) {
      sheinOutputWidthInput.addEventListener('input', () => {
        const widthVal = parseFloat(sheinOutputWidthInput.value);
        if (!isNaN(widthVal) && widthVal > 0) {
          sheinOutputWidthInput.classList.remove('input-error');
          sheinOutputWidthErrorEl.textContent = '';
          sheinOutputWidthErrorEl.style.display = 'none';
        }
      });
    }

    if (sheinOutputHeightInput && sheinOutputHeightErrorEl) {
      sheinOutputHeightInput.addEventListener('input', () => {
        const heightVal = parseFloat(sheinOutputHeightInput.value);
        if (!isNaN(heightVal) && heightVal > 0) {
          sheinOutputHeightInput.classList.remove('input-error');
          sheinOutputHeightErrorEl.textContent = '';
          sheinOutputHeightErrorEl.style.display = 'none';
        }
      });
    }

    // Add input event listener for sheinOutputName to clear error on valid input
    const sheinOutputNameInputForLiveValidation = document.getElementById('sheinOutputName');
    if (sheinOutputNameInputForLiveValidation) {
      sheinOutputNameInputForLiveValidation.addEventListener('input', function() {
        let tempOutputName = this.value.trim();
        // Similar to pdfResizeOutputName, handle potential .pdf extension for validation
        // isValidFilename should handle names with or without extensions correctly.
        const validation = isValidFilename(tempOutputName);
        if (validation.valid) {
          this.classList.remove('input-error');
        }
        // Only for clearing error, not adding it.
      });
    }

    // Apply file-selected-badge styling if needed (assuming styles.css has this class)
    // Ensure initial placeholder text
    if (sheinSelectedFile1Element) sheinSelectedFile1Element.textContent = currentTranslations.noFileSelected || '未选择文件';
    if (sheinSelectedFile2Element) sheinSelectedFile2Element.textContent = currentTranslations.noFileSelected || '未选择文件';


    if (sheinOpenFile1Btn) {
      sheinOpenFile1Btn.addEventListener('click', async () => {
        const newPath = await window.electronAPI.openFile();
        const sheinSelectedFile1ErrorEl = document.getElementById('sheinSelectedFile1Error');
        const sheinOpenFile1Button = document.getElementById('sheinOpenFile1Btn');
        
        // Always clear previous specific warning for EC Rep page count
        if (sheinSelectedFile1ErrorEl) {
            clearInlineFileError('sheinSelectedFile1Error');
        }

        if (!newPath) {
          showToast('操作已取消。', 'info');
          //updateFileSelectionUI(selectedSheinPdf1Path, 'sheinSelectedFile1'); // Update with current (possibly old or empty)
        } else {
          selectedSheinPdf1Path = newPath;
          renderPdfPageToEditor(newPath, 'shein-pdf-1', '欧代PDF');
          appSettings.sheinEcRepPdfPath = selectedSheinPdf1Path;
          // Immediately update UI to show filename and loading state
          updateFileSelectionUI(selectedSheinPdf1Path, 'sheinSelectedFile1', null, null, true);

          try {
            const metadata = await window.electronAPI.getPdfMetadata(selectedSheinPdf1Path);
            // Now update with full metadata
            if (metadata.success) {
              updateFileSelectionUI(selectedSheinPdf1Path, 'sheinSelectedFile1', metadata.pageCount, metadata.size, false);
              if (sheinOpenFile1Button) sheinOpenFile1Button.classList.remove('input-error');
              // No need to clear general error here, as it's for file selection, not page count.
              // The specific page count warning is handled below.

              if (metadata.pageCount !== null && metadata.pageCount !== 1) {
                const warningMsg = `警告：欧代文件通常为1页。当前页数：${metadata.pageCount}`;
                showToast('请检查，欧代PDF文件通常为1页PDF', 'warning', 6000);
                if (sheinSelectedFile1ErrorEl) {
                  sheinSelectedFile1ErrorEl.textContent = warningMsg;
                  sheinSelectedFile1ErrorEl.style.display = 'block';
                  sheinSelectedFile1ErrorEl.classList.add('warning-text'); // Add class for styling
                }
              }
            } else {
              showToast(`无法读取欧代文件元数据: ${metadata.error || '未知错误'}`, 'error');
              updateFileSelectionUI(selectedSheinPdf1Path, 'sheinSelectedFile1', null, null, false); // Show filename at least, remove loading
            }
          } catch (err) {
            showToast(`获取欧代文件元数据时出错: ${err.message}`, 'error');
            updateFileSelectionUI(selectedSheinPdf1Path, 'sheinSelectedFile1', null, null, false); // Show filename at least, remove loading
          }

          // Update output directory display if not globally set
          // Update output directory display if not globally set
          if (!appSettings.outputDirectory) {
            const dirName = getDirnameFrontend(selectedSheinPdf1Path);
            const sheinOutputDirDisplay = document.getElementById('sheinOutputDirDisplay');
            const defaultDirText = currentTranslations.notSetUseDefault || '未设置，使用源文件目录';
            // Only update if the display is still showing the default text.
            if (dirName && sheinOutputDirDisplay.textContent === defaultDirText) {
              const displayText = `${currentTranslations.currentPath || '当前路径'}: ${dirName}`;
              sheinOutputDirDisplay.textContent = displayText;
            }
          }
          const saveResult = await window.electronAPI.saveSettings(appSettings);
          if (!saveResult || !saveResult.success) {
            console.error('Failed to save settings after Shein File 1 selection:', saveResult ? saveResult.error : 'Unknown error');
            showToast('警告：无法保存文件选择设置。', 'warning');
          }
        }
      });
    }

    if (sheinOpenFile2Btn) {
      sheinOpenFile2Btn.addEventListener('click', async () => {
        const newPath = await window.electronAPI.openFile();
        const sheinOpenFile2Button = document.getElementById('sheinOpenFile2Btn');
        const sheinSelectedFile2ErrorEl = document.getElementById('sheinSelectedFile2Error');

        if (!newPath) {
          showToast('操作已取消。', 'info');
          //updateFileSelectionUI(selectedSheinPdf2Path, 'sheinSelectedFile2');
        } else {
          selectedSheinPdf2Path = newPath;
          renderPdfPageToEditor(newPath, 'shein-pdf-2', '条码PDF');
          appSettings.sheinBarcodePdfPath = selectedSheinPdf2Path;
          // Immediately update UI to show filename and loading state
          updateFileSelectionUI(selectedSheinPdf2Path, 'sheinSelectedFile2', null, null, true);

          try {
            const metadata = await window.electronAPI.getPdfMetadata(selectedSheinPdf2Path);
            // Now update with full metadata
            if (metadata.success) {
              updateFileSelectionUI(selectedSheinPdf2Path, 'sheinSelectedFile2', metadata.pageCount, metadata.size, false);
              if (sheinOpenFile2Button) sheinOpenFile2Button.classList.remove('input-error');
              if (sheinSelectedFile2ErrorEl) {
                  clearInlineFileError('sheinSelectedFile2Error'); // Clear general file selection error
              }
            } else {
              showToast(`无法读取条码文件元数据: ${metadata.error || '未知错误'}`, 'error');
              updateFileSelectionUI(selectedSheinPdf2Path, 'sheinSelectedFile2', null, null, false); // Show filename at least, remove loading
            }
          } catch (err) {
            showToast(`获取条码文件元数据时出错: ${err.message}`, 'error');
            updateFileSelectionUI(selectedSheinPdf2Path, 'sheinSelectedFile2', null, null, false); // Show filename at least, remove loading
          }

          // Update output directory display if not globally set
          // Update output directory display if not globally set
          if (!appSettings.outputDirectory) {
            const dirName = getDirnameFrontend(selectedSheinPdf2Path);
            const sheinOutputDirDisplay = document.getElementById('sheinOutputDirDisplay');
            const defaultDirText = currentTranslations.notSetUseDefault || '未设置，使用源文件目录';
            // Only update if the display is still showing the default text.
            if (dirName && sheinOutputDirDisplay.textContent === defaultDirText) {
              const displayText = `${currentTranslations.currentPath || '当前路径'}: ${dirName}`;
              sheinOutputDirDisplay.textContent = displayText;
            }
          }
  
          // Auto-fill output name for Shein 标签 (based on barcode file)
          const sheinOutputNameInput = document.getElementById('sheinOutputName');
          if (sheinOutputNameInput) {
            const baseNameNoExt = getFilenameWithoutExtension(selectedSheinPdf2Path);
            const newOutputName = `${baseNameNoExt}_`; 
            // const newOutputName = `${baseNameNoExt}_Shein标签_${getCurrentHHMMSS()}`; 
            // No .pdf here
            sheinOutputNameInput.value = newOutputName;
            // Trigger input event for live validation and settings saving
            const inputEvent = new Event('input', { bubbles: true });
            sheinOutputNameInput.dispatchEvent(inputEvent);
          }
          
          const saveResult = await window.electronAPI.saveSettings(appSettings); // Save other settings like selected path
          if (!saveResult || !saveResult.success) {
            console.error('Failed to save settings after Shein File 2 selection:', saveResult ? saveResult.error : 'Unknown error');
            showToast('警告：无法保存文件选择设置。', 'warning');
          }
        }
      });
    }

   const sheinKeepAspectRatioCheckbox = document.getElementById('sheinKeepAspectRatio');
   if (sheinKeepAspectRatioCheckbox) {
     sheinKeepAspectRatioCheckbox.addEventListener('change', () => {
       document.querySelectorAll('.draggable-pdf-page').forEach(el => {
         setupInteractForElement(el);
       });
     });
   }


    if (generateSheinLabelBtn) {
      // Event listeners for open/show buttons, defined once
      // openGeneratedFileBtn.addEventListener('click', async () => {
      //   if (currentGeneratedSheinLabelPath) {
      //     try {
      //       await window.electronAPI.openPath(currentGeneratedSheinLabelPath);
      //     } catch (err) {
      //       console.error("Error opening file (Shein 标签):", err);
      //       const openFileErrorMsgShein = `无法打开生成的 Shein 标签 文件。请检查文件是否存在或是否有权限访问。 (错误: ${err.message})`;
      //       showToast(openFileErrorMsgShein, 'error');
      //     }
      //   }
      // });

      // showGeneratedFileInFolderBtn.addEventListener('click', async () => {
      //   if (currentGeneratedSheinLabelPath) {
      //     try {
      //       await window.electronAPI.showItemInFolder(currentGeneratedSheinLabelPath);
      //     } catch (err) {
      //       console.error("Error showing item in folder (Shein 标签):", err);
      //       const showInFolderErrorMsgShein = `无法在文件夹中显示该 Shein 标签 文件。请检查路径是否有效。 (错误: ${err.message})`;
      //       showToast(showInFolderErrorMsgShein, 'error');
      //     }
      //   }
      // });

      // if (sheinCopyFileBtn) {
      //   sheinCopyFileBtn.addEventListener('click', async () => {
      //     if (currentGeneratedSheinLabelPath) {
      //       try {
      //         const copyResult = await window.electronAPI.copyFileToClipboard(currentGeneratedSheinLabelPath);

      //         if (copyResult && copyResult.success) {
      //           if (copyResult.action === 'path_copied_unexpected_fallback') {
      //             showToast(copyResult.message || '未能复制文件本身，已改为复制文件路径至剪贴板。', 'warning', 5000);
      //           } else {
      //             showToast('文件已复制到剪贴板！', 'success');
      //           }
      //           console.log('Copy action result (Shein 标签):', copyResult);
      //         } else {
      //           const defaultCopyErrorShein = '请检查文件是否存在或剪贴板权限。';
      //           const errorMessage = `复制文件失败: ${(copyResult && copyResult.error) ? copyResult.error : defaultCopyErrorShein}`;
      //           console.error("Failed to copy file to clipboard (Shein 标签):", errorMessage);
      //           showToast(errorMessage, 'error');
      //         }
      //       } catch (err) {
      //         console.error("Error during copy file operation (Shein 标签):", err);
      //         const exceptionCopyErrorMsgShein = `复制 Shein 标签 文件时发生意外错误。 (错误: ${err.message})`;
      //         showToast(exceptionCopyErrorMsgShein, 'error');
      //       }
      //     }
      //   });
      // }

      generateSheinLabelBtn.addEventListener('click', async () => {
        const originalButtonText = generateSheinLabelBtn.textContent; // Store original button text
        let startTime = 0;
        let timerInterval;
        generateSheinLabelBtn.disabled = true;
        startTime = Date.now();
        let secondsElapsed = 0;
        generateSheinLabelBtn.textContent = (currentTranslations.processing || '正在处理中... ({seconds}秒)').replace('{seconds}', secondsElapsed);
        // generateSheinLabelBtn.classList.add('processing'); // Will be added after validation

        // sheinResultDiv.innerHTML = ''; // Clear previous results - Removed to preserve history
        sheinResultDiv.className = '';
        // sheinResultDiv.style.display = 'none'; // Hide when resetting - Removed to prevent hiding history on validation fail
        sheinPostProcessActionsDiv.style.display = 'none'; // Hide actions at the start
        currentGeneratedSheinLabelPath = ''; // Reset path

        // Reset inline error messages for Shein file inputs
        const sheinOpenFile1ButtonForReset = document.getElementById('sheinOpenFile1Btn');
        const sheinSelectedFile1ErrorForReset = document.getElementById('sheinSelectedFile1Error');
        if (sheinOpenFile1ButtonForReset && sheinSelectedFile1ErrorForReset) {
            sheinOpenFile1ButtonForReset.classList.remove('input-error');
            sheinSelectedFile1ErrorForReset.textContent = '';
            sheinSelectedFile1ErrorForReset.style.display = 'none';
        }

        const sheinOpenFile2ButtonForReset = document.getElementById('sheinOpenFile2Btn');
        const sheinSelectedFile2ErrorForReset = document.getElementById('sheinSelectedFile2Error');
        if (sheinOpenFile2ButtonForReset && sheinSelectedFile2ErrorForReset) {
            sheinOpenFile2ButtonForReset.classList.remove('input-error');
            sheinSelectedFile2ErrorForReset.textContent = '';
            sheinSelectedFile2ErrorForReset.style.display = 'none';
        }
        // Reset inline error messages for Shein custom dimensions
        const sheinOutputWidthErrorElForReset = document.getElementById('sheinOutputWidthError');
        const sheinOutputHeightErrorElForReset = document.getElementById('sheinOutputHeightError');
        if (sheinOutputWidthInput && sheinOutputWidthErrorElForReset) {
            sheinOutputWidthInput.classList.remove('input-error');
            sheinOutputWidthErrorElForReset.textContent = '';
            sheinOutputWidthErrorElForReset.style.display = 'none';
        }
        if (sheinOutputHeightInput && sheinOutputHeightErrorElForReset) {
            sheinOutputHeightInput.classList.remove('input-error');
            sheinOutputHeightErrorElForReset.textContent = '';
            sheinOutputHeightErrorElForReset.style.display = 'none';
        }

        let sheinValidationPassed = true;

        if (!selectedSheinPdf1Path) {
          const sheinOpenFile1Button = document.getElementById('sheinOpenFile1Btn');
          const sheinSelectedFile1ErrorEl = document.getElementById('sheinSelectedFile1Error');
          const errorMessage1 = currentTranslations.errorSelectEcRepFile || '请选择欧代文件。';
          showToast(errorMessage1, 'error');
          if (sheinOpenFile1Button) {
              sheinOpenFile1Button.classList.add('input-error');
          }
          if (sheinSelectedFile1ErrorEl) {
              sheinSelectedFile1ErrorEl.textContent = errorMessage1;
              sheinSelectedFile1ErrorEl.style.display = 'block';
          } else {
              console.error("Shein 标签 Error: sheinSelectedFile1Error element not found in DOM!");
              // if (sheinResultDiv) { // Removed to prevent clearing history
              //     sheinResultDiv.innerHTML = '<p>请选择欧代文件 (UI Error: msg element missing)</p>';
              //     sheinResultDiv.className = 'error';
              //     sheinResultDiv.style.display = 'block';
              // }
          }
          sheinValidationPassed = false;
        }

        if (!selectedSheinPdf2Path) {
          const sheinOpenFile2Button = document.getElementById('sheinOpenFile2Btn');
          const sheinSelectedFile2ErrorEl = document.getElementById('sheinSelectedFile2Error');
          const errorMessage2 = currentTranslations.errorSelectBarcodeFile || '请选择条码文件。';
          showToast(errorMessage2, 'error');
          if (sheinOpenFile2Button) {
              sheinOpenFile2Button.classList.add('input-error');
          }
          if (sheinSelectedFile2ErrorEl) {
              sheinSelectedFile2ErrorEl.textContent = errorMessage2;
              sheinSelectedFile2ErrorEl.style.display = 'block';
          } else {
              console.error("Shein 标签 Error: sheinSelectedFile2Error element not found in DOM!");
              // if (sheinResultDiv) { // Fallback - Removed to prevent clearing history
              //     sheinResultDiv.innerHTML = '<p>请选择条码文件 (UI Error: msg element missing)</p>';
              //     sheinResultDiv.className = 'error';
              //     sheinResultDiv.style.display = 'block';
              // }
          }
          sheinValidationPassed = false;
        }
        
        const sheinPageSizeSelectedValue = sheinOutputPageSizeSelect.value;
        let outputWidth = parseFloat(sheinOutputWidthInput.value);
        let outputHeight = parseFloat(sheinOutputHeightInput.value);
        const sheinOutputWidthErrorEl = document.getElementById('sheinOutputWidthError');
        const sheinOutputHeightErrorEl = document.getElementById('sheinOutputHeightError');

        if (sheinPageSizeSelectedValue === 'custom') {
            if (isNaN(outputWidth) || outputWidth <= 0) {
                const sheinWidthErrorMessage = currentTranslations.errorInvalidWidth || '宽度必须是有效的正数。';
                showToast(sheinWidthErrorMessage, 'error');
                if (sheinOutputWidthInput) sheinOutputWidthInput.classList.add('input-error');
                if (sheinOutputWidthErrorEl) {
                    sheinOutputWidthErrorEl.textContent = sheinWidthErrorMessage;
                    sheinOutputWidthErrorEl.style.display = 'block';
                }
                if (sheinValidationPassed && sheinOutputWidthInput) sheinOutputWidthInput.focus();
                sheinValidationPassed = false;
            }
            if (isNaN(outputHeight) || outputHeight <= 0) {
                const sheinHeightErrorMessage = currentTranslations.errorInvalidHeight || '高度必须是有效的正数。';
                showToast(sheinHeightErrorMessage, 'error');
                if (sheinOutputHeightInput) sheinOutputHeightInput.classList.add('input-error');
                if (sheinOutputHeightErrorEl) {
                    sheinOutputHeightErrorEl.textContent = sheinHeightErrorMessage;
                    sheinOutputHeightErrorEl.style.display = 'block';
                }
                if (sheinValidationPassed && sheinOutputHeightInput) sheinOutputHeightInput.focus();
                else if (!sheinValidationPassed && sheinOutputWidthInput && document.activeElement !== sheinOutputWidthInput && sheinOutputHeightInput) {
                     sheinOutputHeightInput.focus();
                } else if (!sheinOutputWidthInput && sheinOutputHeightInput) {
                    sheinOutputHeightInput.focus();
                }
                sheinValidationPassed = false;
            }
        } else {
            const presetSize = pageSizeMapMM[sheinPageSizeSelectedValue];
            if (presetSize) {
                outputWidth = presetSize.width;
                outputHeight = presetSize.height;
            } else {
                console.error("Shein 标签: Selected preset size not found in map. Using defaults.");
                outputWidth = 70;
                outputHeight = 60;
            }
        }

        if (!sheinValidationPassed) {
          generateSheinLabelBtn.disabled = false;
          generateSheinLabelBtn.textContent = originalButtonText;
          // generateSheinLabelBtn.classList.remove('processing'); // Not added yet
          if(timerInterval) clearInterval(timerInterval); // Clear interval if validation fails after it started (though unlikely here)
          return;
        }

        const clearSheinLabelFormBtn = document.getElementById('clearSheinLabelFormBtn'); // Get clear button
        if (clearSheinLabelFormBtn) clearSheinLabelFormBtn.disabled = true; // Disable clear button

        // If validation passed, now add processing class and start timer
        generateSheinLabelBtn.classList.add('processing');
        timerInterval = setInterval(() => {
          secondsElapsed++;
          generateSheinLabelBtn.textContent = (currentTranslations.processing || '正在处理中... ({seconds}秒)').replace('{seconds}', secondsElapsed);
        }, 1000);

        // getCurrentHHMMSS is now a global helper function

        let outputName = sheinOutputNameInput.value.trim();
        // Auto-generation of outputName if empty is now handled by file selection,
        // but keep this as a fallback if user clears it and then clicks process.
        if (!outputName) {
          const base = selectedSheinPdf2Path ? getFilenameWithoutExtension(selectedSheinPdf2Path) : 'SheinLabel_file';
          // outputName = `${base}_Shein标签_${getCurrentHHMMSS()}`; // No .pdf here
          outputName = `${base}_`; // No .pdf here
          // sheinOutputNameInput.value = outputName; // Optionally update the input if it was empty
        }

        // Validate the name part without .pdf
        const sheinFilenameValidation = isValidFilename(outputName);
        if (!sheinFilenameValidation.valid) {
          showToast(sheinFilenameValidation.message, 'error');
          if (sheinOutputNameInput) {
            sheinOutputNameInput.classList.add('input-error');
            sheinOutputNameInput.focus();
          }
          // Restore button state if validation fails before processing starts
          // generateSheinLabelBtn, originalButtonText, timerInterval are defined in this scope
          generateSheinLabelBtn.disabled = false;
          generateSheinLabelBtn.textContent = originalButtonText;
          generateSheinLabelBtn.classList.remove('processing'); // Remove if added before validation
          if (timerInterval) clearInterval(timerInterval);
          return;
        }
        
       const editorArea = document.getElementById('shein-editor-area');
       const imagesData = [];
       const draggableElements = editorArea.querySelectorAll('.draggable-pdf-page');
       const parentRect = editorArea.getBoundingClientRect(); // Get parent rect once.

       draggableElements.forEach(el => {
           const rect = el.getBoundingClientRect();
           imagesData.push({
               id: el.id,
               path: el.dataset.pdfPath,
               x: rect.left - parentRect.left, // Calculate relative X
               y: rect.top - parentRect.top,   // Calculate relative Y
               width: rect.width,
               height: rect.height,
           });
       });

        const params = {
          pdf1Path: selectedSheinPdf1Path,
          pdf2Path: selectedSheinPdf2Path,
          outputName: outputName.toLowerCase().endsWith('.pdf') ? outputName : outputName + '.pdf', // Add .pdf before sending to API
          outputWidthMM: outputWidth,
          outputHeightMM: outputHeight,
          outputDir: appSettings.outputDirectory || '',
          images: imagesData,
          editorWidth: parentRect.width, // Use reliable width from getBoundingClientRect
          editorHeight: parentRect.height // Use reliable height from getBoundingClientRect
        };

        try {
          const result = await window.electronAPI.generateSheinLabel(params);
          const endTime = Date.now();
          const totalTimeSeconds = ((endTime - startTime) / 1000).toFixed(2);
          const sheinResultContainer = document.getElementById('sheinResult'); // Renamed for clarity
          const generatedPath = (result && result.success) ? result.path : null;

          const entryDiv = document.createElement('div');
          entryDiv.className = 'result-entry'; // Base class
          let entryHtml = '';

          if (result && result.success && generatedPath) {
            // currentGeneratedSheinLabelPath = generatedPath; // This global var is less important now
            showToast(currentTranslations.sheinLabelSuccess || 'Shein 标签 生成成功！', 'success');
            entryDiv.classList.add('success-entry'); // Use new specific success class
            entryHtml = `<p><strong>${currentTranslations.processingStatusSuccess || '处理成功'}</strong></p><p>${(currentTranslations.savePath || '保存路径：{path}').replace('{path}', generatedPath)}</p>`;
            if (result.outputFileSize !== null && result.outputFileSize !== undefined) {
              let sizeAndPages = `${(currentTranslations.fileSize || '文件大小：{size}').replace('{size}', formatBytes(result.outputFileSize))}`;
              if (result.outputPageCount !== null && result.outputPageCount !== undefined) {
                sizeAndPages += `，${(currentTranslations.pageCount || '页数：{count}').replace('{count}', result.outputPageCount)}`;
              }
              entryHtml += `<p>${sizeAndPages}</p>`;
            } else if (result.outputPageCount !== null && result.outputPageCount !== undefined) {
               entryHtml += `<p>${(currentTranslations.pageCount || '页数：{count}').replace('{count}', result.outputPageCount)}</p>`;
            }
            if(result.metadataError){
                entryHtml += `<p style="color: orange;">${(currentTranslations.warningOutputMetadata || '输出文件元数据警告: {error}').replace('{error}', result.metadataError)}</p>`;
            }
          } else { // API error or processing failure from electronAPI.generateSheinLabel
            entryDiv.classList.add('error-entry'); // Use new specific error class
            const errorMessage = (result && result.error) ? result.error : (currentTranslations.unknownProcessingError || '未知处理错误。');
            showToast((currentTranslations.sheinLabelFailed || 'Shein 标签 生成失败：{error}').replace('{error}', errorMessage), 'error');
            entryHtml = `<p class="error-message-text"><strong>${currentTranslations.processingStatusFailed || '处理失败：'}</strong>${errorMessage}</p>`; // Add class to error message paragraph
          }

          const startTimeFormatted = new Date(startTime).toLocaleString('zh-CN', { year: 'numeric', month: '2-digit', day: '2-digit', hour: '2-digit', minute: '2-digit', second: '2-digit', hour12: false });
          entryHtml += `<p>${(currentTranslations.processingStartTime || '处理开始时间：{time}').replace('{time}', startTimeFormatted)}</p>`;
          entryHtml += `<p>${(currentTranslations.totalTime || '总耗时：{seconds}秒').replace('{seconds}', totalTimeSeconds)}</p>`;
          entryDiv.innerHTML = entryHtml;

          // Create and append action buttons for this entry
          const actionsDiv = document.createElement('div');
          actionsDiv.className = 'action-buttons-container'; // Use new class for button container

          const openBtnShein = document.createElement('button');
          openBtnShein.textContent = currentTranslations.openFile || '打开文件';
          openBtnShein.className = 'action-button action-button-primary'; // Primary action
          if (!generatedPath) openBtnShein.disabled = true;
          openBtnShein.addEventListener('click', async () => {
            if (generatedPath) {
              try { await window.electronAPI.openPath(generatedPath); }
              catch (err) { showToast(`无法打开文件: ${err.message}`, 'error'); }
            }
          });
          actionsDiv.appendChild(openBtnShein);

          const showInFolderBtnShein = document.createElement('button');
          showInFolderBtnShein.textContent = currentTranslations.openFolder || '打开文件夹';
          showInFolderBtnShein.className = 'action-button';
          if (!generatedPath) showInFolderBtnShein.disabled = true;
          showInFolderBtnShein.addEventListener('click', async () => {
            if (generatedPath) {
              try { await window.electronAPI.showItemInFolder(generatedPath); }
              catch (err) { showToast(`无法在文件夹中显示: ${err.message}`, 'error'); }
            }
          });
          actionsDiv.appendChild(showInFolderBtnShein);

          const copyBtnShein = document.createElement('button');
          copyBtnShein.textContent = currentTranslations.copyFile || '复制文件';
          copyBtnShein.className = 'action-button';
          copyBtnShein.title = currentTranslations.copyFileTooltip || '尝试复制文件到剪贴板 (若失败则复制路径)';
          if (!generatedPath) copyBtnShein.disabled = true;
          copyBtnShein.addEventListener('click', async () => {
            if (generatedPath) {
              try {
                const copyResult = await window.electronAPI.copyFileToClipboard(generatedPath);
                if (copyResult && copyResult.success) {
                  showToast(copyResult.action === 'path_copied_unexpected_fallback' ? (copyResult.message || '未能复制文件本身，已改为复制文件路径至剪贴板。') : '文件已复制到剪贴板！', copyResult.action === 'path_copied_unexpected_fallback' ? 'warning' : 'success');
                } else {
                  showToast(`复制文件失败: ${(copyResult && copyResult.error) ? copyResult.error : '未知错误'}`, 'error');
                }
              } catch (err) { showToast(`复制操作出错: ${err.message}`, 'error'); }
            }
          });
          actionsDiv.appendChild(copyBtnShein);
          entryDiv.appendChild(actionsDiv);

          if (sheinResultContainer) {
            sheinResultContainer.prepend(entryDiv);
            sheinResultContainer.style.display = 'block';
          }
        } catch (error) {
          console.error('Error calling generateSheinLabel:', error);
          const endTime = Date.now();
          const totalTimeSeconds = ((endTime - startTime) / 1000).toFixed(2);
          const sheinResultContainerForError = document.getElementById('sheinResult'); // Target container

          const errorEntryDiv = document.createElement('div');
          errorEntryDiv.className = 'result-entry error-entry'; // Add new specific error class
          let errorHtml = `<p class="error-message-text"><strong>${currentTranslations.clientError || '客户端错误：'}</strong>${error.message || (currentTranslations.unexpectedClientError || '发生意外错误。')}</p>`; // Add class to error message paragraph
          
          const startTimeFormatted = new Date(startTime).toLocaleString('zh-CN', { year: 'numeric', month: '2-digit', day: '2-digit', hour: '2-digit', minute: '2-digit', second: '2-digit', hour12: false });
          errorHtml += `<p>${(currentTranslations.processingStartTime || '处理开始时间：{time}').replace('{time}', startTimeFormatted)}</p>`;
          errorHtml += `<p>${(currentTranslations.totalTime || '总耗时：{seconds}秒').replace('{seconds}', totalTimeSeconds)}</p>`;
          errorEntryDiv.innerHTML = errorHtml;

          // Add disabled action buttons for client errors as well for consistency
          const errorActionsDiv = document.createElement('div');
          errorActionsDiv.className = 'action-buttons-container'; // Use new class for button container
          ['打开文件', '打开文件夹', '复制文件'].forEach((text, index) => {
              const btn = document.createElement('button');
              btn.textContent = text;
              // Apply primary style to "打开文件"
              btn.className = (index === 0) ? 'action-button action-button-primary' : 'action-button';
              btn.disabled = true;
              errorActionsDiv.appendChild(btn);
          });
          errorEntryDiv.appendChild(errorActionsDiv);

          if (sheinResultContainerForError) {
            sheinResultContainerForError.prepend(errorEntryDiv);
            sheinResultContainerForError.style.display = 'block';
          }
          showToast(`Shein 标签 生成出错：${error.message || '发生意外错误。'}`, 'error');
        } finally {
          if (timerInterval) clearInterval(timerInterval);
            generateSheinLabelBtn.disabled = false;
            generateSheinLabelBtn.textContent = originalButtonText;
            generateSheinLabelBtn.classList.remove('processing');
            if (clearSheinLabelFormBtn) clearSheinLabelFormBtn.disabled = false; // Re-enable clear button
          }
      });

    // Shein 标签 View - Clear Form Button
    const clearSheinLabelFormBtn = document.getElementById('clearSheinLabelFormBtn');
    if (clearSheinLabelFormBtn) {
      clearSheinLabelFormBtn.addEventListener('click', async () => {
        // Clear file selections
        selectedSheinPdf1Path = '';
        updateFileSelectionUI(selectedSheinPdf1Path, 'sheinSelectedFile1', null, null);
        appSettings.sheinEcRepPdfPath = '';
        const sheinOpenFile1Button = document.getElementById('sheinOpenFile1Btn');
        if (sheinOpenFile1Button) sheinOpenFile1Button.classList.remove('input-error');
        clearInlineFileError('sheinSelectedFile1Error'); // Clear specific EC rep warning too

        selectedSheinPdf2Path = '';
        updateFileSelectionUI(selectedSheinPdf2Path, 'sheinSelectedFile2', null, null);
        appSettings.sheinBarcodePdfPath = '';
        const sheinOpenFile2Button = document.getElementById('sheinOpenFile2Btn');
        if (sheinOpenFile2Button) sheinOpenFile2Button.classList.remove('input-error');
        clearInlineFileError('sheinSelectedFile2Error');

        // Clear output name
        if (sheinOutputNameInput) sheinOutputNameInput.value = '';
        appSettings.sheinOutputName = '';

        // Reset output page size and custom dimensions
        if (sheinOutputPageSizeSelect) sheinOutputPageSizeSelect.value = 'Shein'; // Default to Shein
        appSettings.sheinOutputPageSize = 'Shein';
        if (sheinOutputCustomDimensionsDiv) sheinOutputCustomDimensionsDiv.style.display = 'none';
        
        if (sheinOutputWidthInput) {
          sheinOutputWidthInput.value = '70'; // Default Shein width
          sheinOutputWidthInput.classList.remove('input-error');
        }
        appSettings.sheinOutputWidth = '70';
        const sheinOutputWidthErrorEl = document.getElementById('sheinOutputWidthError');
        if (sheinOutputWidthErrorEl) {
          sheinOutputWidthErrorEl.textContent = '';
          sheinOutputWidthErrorEl.style.display = 'none';
        }

        if (sheinOutputHeightInput) {
          sheinOutputHeightInput.value = '60'; // Default Shein height
          sheinOutputHeightInput.classList.remove('input-error');
        }
        appSettings.sheinOutputHeight = '60';
        const sheinOutputHeightErrorEl = document.getElementById('sheinOutputHeightError');
        if (sheinOutputHeightErrorEl) {
          sheinOutputHeightErrorEl.textContent = '';
          sheinOutputHeightErrorEl.style.display = 'none';
        }
        
        // Trigger change on select to update UI correctly (e.g., hide custom dimensions)
        if (sheinOutputPageSizeSelect) {
            const event = new Event('change', { bubbles: true });
            sheinOutputPageSizeSelect.dispatchEvent(event);
        }

        // Clear the editor area
        const editorArea = document.getElementById('shein-editor-area');
        if (editorArea) {
          editorArea.innerHTML = '';
        }

        // Clear result and post-process actions
        if (sheinResultDiv) {
          sheinResultDiv.innerHTML = ''; // Clear all dynamically added entries
          sheinResultDiv.className = '';
          sheinResultDiv.style.display = 'none';
        }
        // if (sheinPostProcessActionsDiv) { // This div is no longer used for dynamic entries
        //   sheinPostProcessActionsDiv.style.display = 'none';
        // }
        // currentGeneratedSheinLabelPath = ''; // This global var is no longer the primary source for path

        // Clear output directory
        appSettings.outputDirectory = '';
        const defaultDirText = currentTranslations.notSetUseDefault || '未设置，使用源文件目录';
        document.getElementById('outputDirDisplay').textContent = defaultDirText;
        document.getElementById('sheinOutputDirDisplay').textContent = defaultDirText;

        await window.electronAPI.saveSettings(appSettings);
        showToast(currentTranslations['toast.sheinFormCleared'] || 'Shein 标签 生成已清空', 'info');
      });
    }
    }
    // --- End Shein 标签 Feature ---

    // --- Custom Select Dropdown Logic ---
    function initializeCustomSelect(originalSelectElement) {
      if (!originalSelectElement) return;

      const customSelectContainer = originalSelectElement.parentElement.querySelector('.custom-select-container');
      if (!customSelectContainer) return;

      const trigger = customSelectContainer.querySelector('.custom-select-trigger');
      const optionsContainer = customSelectContainer.querySelector('.custom-select-options');
      const triggerSpan = trigger.querySelector('span');

      // Clear existing custom options
      optionsContainer.innerHTML = '';

      // Populate custom options from original select
      Array.from(originalSelectElement.options).forEach(option => {
        const customOption = document.createElement('div');
        customOption.classList.add('custom-select-option');
        customOption.textContent = option.textContent;
        customOption.dataset.value = option.value;
        if (option.selected) {
          triggerSpan.textContent = option.textContent;
          customOption.classList.add('selected');
        }
        
        customOption.addEventListener('click', () => {
          // Update trigger text
          triggerSpan.textContent = customOption.textContent;
          
          // Update original select value
          originalSelectElement.value = customOption.dataset.value;
          
          // Remove 'selected' from previously selected custom option
          const currentlySelected = optionsContainer.querySelector('.custom-select-option.selected');
          if (currentlySelected) {
            currentlySelected.classList.remove('selected');
          }
          // Add 'selected' to current custom option
          customOption.classList.add('selected');
          
          // Close options
          optionsContainer.style.display = 'none';
          customSelectContainer.classList.remove('open');
          
          // Dispatch change event on original select
          const changeEvent = new Event('change', { bubbles: true });
          originalSelectElement.dispatchEvent(changeEvent);
        });
        optionsContainer.appendChild(customOption);
      });

      trigger.addEventListener('click', (e) => {
        e.stopPropagation(); // Prevent click from bubbling to document listener immediately
        const isOpen = optionsContainer.style.display === 'block';
        closeAllCustomSelects(customSelectContainer); // Close others before opening/closing current
        if (!isOpen) {
          optionsContainer.style.display = 'block';
          customSelectContainer.classList.add('open');
        } else {
          // Already handled by closeAllCustomSelects if it was this one
        }
      });
    }

    function closeAllCustomSelects(exceptThisOne = null) {
      document.querySelectorAll('.custom-select-container').forEach(container => {
        if (container !== exceptThisOne) {
          container.querySelector('.custom-select-options').style.display = 'none';
          container.classList.remove('open');
        }
      });
    }

    document.addEventListener('click', () => {
      closeAllCustomSelects();
    });

    // --- Load All Settings and Initialize UI ---
    async function loadAndApplySettings() {
      appSettings = await window.electronAPI.getSettings();
      if (!appSettings || Object.keys(appSettings).length === 0) {
        appSettings = { // Default structure if no settings file or empty
          activeView: defaultViewId,
          theme: 'light',
          language: 'zh-CN',
          outputDirectory: '',
          pdfResizeSelectedPath: '',
          sheinEcRepPdfPath: '',
          sheinBarcodePdfPath: '',
          pdfResizeOutputName: '',
          pageSize: 'Shein',
          customWidth: '',
          customHeight: '',
          sheinOutputName: '',
          sheinOutputPageSize: 'Shein',
          sheinOutputWidth: '70',
          sheinOutputHeight: '60',
          sheinEditorLayout: []
        };
      }

      // Activate saved view or default
      if (!activateView(appSettings.activeView || defaultViewId)) {
         activateView(defaultViewId); // Fallback if saved view is invalid
      }
      
      // Set theme (without re-saving immediately)
      await setTheme(appSettings.theme || 'light', false);

      // Set language
      const savedLang = appSettings.language || 'zh-CN';
      languageSelector.value = savedLang;
      await loadTranslations(savedLang);

      // Load selected file paths and their metadata
      selectedFilePath = appSettings.pdfResizeSelectedPath || '';
      if (selectedFilePath) {
        // On load, show loading state first, then fetch metadata
        updateFileSelectionUI(selectedFilePath, 'selectedFile', null, null, true);
        try {
          const metadata = await window.electronAPI.getPdfMetadata(selectedFilePath);
          updateFileSelectionUI(selectedFilePath, 'selectedFile', metadata.pageCount, metadata.size, false);
        } catch (e) { updateFileSelectionUI(selectedFilePath, 'selectedFile', null, null, false); /* Show filename at least, remove loading */ }
      } else {
        updateFileSelectionUI(null, 'selectedFile');
      }

      selectedSheinPdf1Path = appSettings.sheinEcRepPdfPath || '';
      if (selectedSheinPdf1Path) {
        updateFileSelectionUI(selectedSheinPdf1Path, 'sheinSelectedFile1', null, null, true);
        try {
          const metadata = await window.electronAPI.getPdfMetadata(selectedSheinPdf1Path);
          updateFileSelectionUI(selectedSheinPdf1Path, 'sheinSelectedFile1', metadata.pageCount, metadata.size, false);
           // Also re-check EC Rep page count warning on load
          const sheinSelectedFile1ErrorEl = document.getElementById('sheinSelectedFile1Error');
          if (sheinSelectedFile1ErrorEl) clearInlineFileError('sheinSelectedFile1Error'); // Clear previous before check
          if (metadata.success && metadata.pageCount !== null && metadata.pageCount !== 1) {
            const warningMsg = `警告：欧代文件通常为1页。当前页数：${metadata.pageCount}`;
            // No toast on load, just inline warning
            if (sheinSelectedFile1ErrorEl) {
              sheinSelectedFile1ErrorEl.textContent = warningMsg;
              sheinSelectedFile1ErrorEl.style.display = 'block';
              sheinSelectedFile1ErrorEl.classList.add('warning-text');
            }
          }
        } catch (e) { updateFileSelectionUI(selectedSheinPdf1Path, 'sheinSelectedFile1', null, null, false); }
      } else {
        updateFileSelectionUI(null, 'sheinSelectedFile1');
        clearInlineFileError('sheinSelectedFile1Error');
      }

      selectedSheinPdf2Path = appSettings.sheinBarcodePdfPath || '';
      if (selectedSheinPdf2Path) {
        updateFileSelectionUI(selectedSheinPdf2Path, 'sheinSelectedFile2', null, null, true);
        try {
          const metadata = await window.electronAPI.getPdfMetadata(selectedSheinPdf2Path);
          updateFileSelectionUI(selectedSheinPdf2Path, 'sheinSelectedFile2', metadata.pageCount, metadata.size, false);
        } catch (e) { updateFileSelectionUI(selectedSheinPdf2Path, 'sheinSelectedFile2', null, null, false); }
      } else {
        updateFileSelectionUI(null, 'sheinSelectedFile2');
      }
      
      // Load output directory
      const outputDir = appSettings.outputDirectory || '';
      const outputDirDisplay = document.getElementById('outputDirDisplay');
      const sheinOutputDirDisplay = document.getElementById('sheinOutputDirDisplay');
      const defaultText = currentTranslations.notSetUseDefault || '未设置，使用源文件目录';
      if (outputDirDisplay) {
        outputDirDisplay.textContent = outputDir ? `${currentTranslations.currentPath || '当前路径'}: ${outputDir}` : defaultText;
      }
      if (sheinOutputDirDisplay) {
        sheinOutputDirDisplay.textContent = outputDir ? `${currentTranslations.currentPath || '当前路径'}: ${outputDir}` : defaultText;
      }

      // This logic is now handled by the file selection events, but we can keep a fallback here on load.
      if (!outputDir) {
        if (selectedFilePath) {
            const dirName = getDirnameFrontend(selectedFilePath);
            if(dirName) document.getElementById('outputDirDisplay').textContent = `${currentTranslations.currentPath || '当前路径'}: ${dirName}`;
        }
        if (selectedSheinPdf1Path || selectedSheinPdf2Path) {
            const sheinPath = selectedSheinPdf2Path || selectedSheinPdf1Path; // Prefer barcode path
            const dirName = getDirnameFrontend(sheinPath);
            if(dirName) document.getElementById('sheinOutputDirDisplay').textContent = `${currentTranslations.currentPath || '当前路径'}: ${dirName}`;
        }
      }

      // Load form elements
      const formElementsToPersist = [
        { id: 'pdfResizeOutputName', type: 'text' },
        { id: 'pageSize', type: 'select' },
        { id: 'customWidth', type: 'number' },
        { id: 'customHeight', type: 'number' },
        { id: 'sheinOutputName', type: 'text' },
        { id: 'sheinOutputPageSize', type: 'select' },
        { id: 'sheinOutputWidth', type: 'number' },
        { id: 'sheinOutputHeight', type: 'number' }
      ];
      
      // Add event listeners for Shein output dimensions to update editor size
       if (sheinOutputWidthInput) {
           sheinOutputWidthInput.addEventListener('input', updateSheinEditorAreaSize);
       }
       if (sheinOutputHeightInput) {
           sheinOutputHeightInput.addEventListener('input', updateSheinEditorAreaSize);
       }

      formElementsToPersist.forEach(elementConfig => {
        const el = document.getElementById(elementConfig.id);
        if (el) {
          // Load saved value from appSettings
          const savedValue = appSettings[elementConfig.id];
          if (savedValue !== undefined && savedValue !== null && savedValue !== '') {
            el.value = savedValue;
          }

          // Special handling for select elements to trigger dependent UI updates
          if (elementConfig.type === 'select') {
            setTimeout(() => {
              const event = new Event('change', { bubbles: true });
              el.dispatchEvent(event);
            }, 0);
          }
          
          // Attach saver
          const eventType = (el.tagName === 'SELECT' || elementConfig.type === 'select') ? 'change' : 'input';
          el.addEventListener(eventType, async () => { // Already async, ensure it's correct
            appSettings[el.id] = el.value;
            await window.electronAPI.saveSettings(appSettings);
          });
        }
      });

      // Initialize custom selects after settings are loaded and original selects are populated
      const pageSizeSelectEl = document.getElementById('pageSize');
      const sheinOutputPageSizeSelectEl = document.getElementById('sheinOutputPageSize');
      
      if (pageSizeSelectEl) initializeCustomSelect(pageSizeSelectEl);
      if (sheinOutputPageSizeSelectEl) initializeCustomSelect(sheinOutputPageSizeSelectEl);

      // Ensure custom select trigger text is updated if settings load changes the original select's value
      // This is important if the default selected option in HTML differs from the loaded setting.
      if (pageSizeSelectEl && appSettings.pageSize) {
          const customTriggerSpan = pageSizeSelectEl.parentElement.querySelector('.custom-select-trigger span');
          const selectedOption = Array.from(pageSizeSelectEl.options).find(opt => opt.value === appSettings.pageSize);
          if (customTriggerSpan && selectedOption) {
              customTriggerSpan.textContent = selectedOption.textContent;
              // Also mark the correct custom option as selected
              const customOptionsContainer = pageSizeSelectEl.parentElement.querySelector('.custom-select-options');
              const currentCustomSelected = customOptionsContainer.querySelector('.custom-select-option.selected');
              if(currentCustomSelected) currentCustomSelected.classList.remove('selected');
              const newCustomSelected = customOptionsContainer.querySelector(`.custom-select-option[data-value="${appSettings.pageSize}"]`);
              if(newCustomSelected) newCustomSelected.classList.add('selected');
          }
      }
      if (sheinOutputPageSizeSelectEl && appSettings.sheinOutputPageSize) {
          const customTriggerSpan = sheinOutputPageSizeSelectEl.parentElement.querySelector('.custom-select-trigger span');
          const selectedOption = Array.from(sheinOutputPageSizeSelectEl.options).find(opt => opt.value === appSettings.sheinOutputPageSize);
          if (customTriggerSpan && selectedOption) {
              customTriggerSpan.textContent = selectedOption.textContent;
              const customOptionsContainer = sheinOutputPageSizeSelectEl.parentElement.querySelector('.custom-select-options');
              const currentCustomSelected = customOptionsContainer.querySelector('.custom-select-option.selected');
              if(currentCustomSelected) currentCustomSelected.classList.remove('selected');
              const newCustomSelected = customOptionsContainer.querySelector(`.custom-select-option[data-value="${appSettings.sheinOutputPageSize}"]`);
              if(newCustomSelected) newCustomSelected.classList.add('selected');
          }
      }

      // --- Shein Editor State Restoration ---
      const renderPromises = [];
      // Re-check paths from appSettings as they are the source of truth
      if (appSettings.sheinEcRepPdfPath) {
          renderPromises.push(renderPdfPageToEditor(appSettings.sheinEcRepPdfPath, 'shein-pdf-1', '欧代PDF'));
      }
      if (appSettings.sheinBarcodePdfPath) {
          renderPromises.push(renderPdfPageToEditor(appSettings.sheinBarcodePdfPath, 'shein-pdf-2', '条码PDF'));
      }

      if (renderPromises.length > 0) {
           console.log('Found saved PDFs, rendering them to editor...');
           await Promise.all(renderPromises);
           console.log('PDFs rendered, applying saved layout.');
           // After rendering is complete, apply any saved custom layout,
           // overriding the default template layout that was applied during rendering.
           applySavedLayout();
      }
      // --- End Shein Editor State Restoration ---
    }

    loadAndApplySettings().then(() => {
       updateSheinEditorAreaSize(); // Set initial size after settings are loaded
    });

    // --- Output Directory Selection Logic ---
    const setupOutputDirButton = (buttonId, displayId) => {
      const button = document.getElementById(buttonId);
      if (button) {
        button.addEventListener('click', async () => {
          const newDir = await window.electronAPI.selectDirectory();
          if (newDir) {
            appSettings.outputDirectory = newDir;
            await window.electronAPI.saveSettings(appSettings);
            const displayText = `${currentTranslations.currentPath || '当前路径'}: ${newDir}`;
            // Update both displays to keep them in sync
            document.getElementById('outputDirDisplay').textContent = displayText;
            document.getElementById('sheinOutputDirDisplay').textContent = displayText;
            showToast((currentTranslations.outputDirSet || '输出目录已设置为: {dir}').replace('{dir}', newDir), 'success');
          } else {
            showToast(currentTranslations.operationCancelled || '操作已取消。', 'info');
          }
        });
      }
    };

    setupOutputDirButton('selectOutputDirBtn', 'outputDirDisplay');
    setupOutputDirButton('sheinSelectOutputDirBtn', 'sheinOutputDirDisplay');
  })
</script>

<!-- Toast Notification Container -->
<div id="toastContainer" class="toast-container">
  <!-- Toasts will be dynamically added here by JavaScript -->
</div>

<!-- Update Notification Container -->
<div id="updateNotificationContainer" class="update-notification-container">
    <!-- Update notifications will be dynamically added here -->
</div>
</body>
</html>
