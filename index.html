<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>PDF Processor</title>
  <link rel="stylesheet" href="styles.css">
</head>
<body>
  <div class="title-bar">
    <div class="title-bar-drag-region"></div>
    <div class="title-bar-text">PDF å·¥å…·é›†</div>
    <div class="title-bar-controls">
      <button id="minimize-btn" class="title-bar-button" aria-label="æœ€å°åŒ–">
        <svg aria-hidden="true" version="1.1" width="10" height="10"><path d="M 0,5 10,5 10,6 0,6 Z" /></svg>
      </button>
      <button id="maximize-restore-btn" class="title-bar-button" aria-label="æœ€å¤§åŒ–">
        <svg aria-hidden="true" version="1.1" width="10" height="10"><path d="M 0,0 0,10 10,10 10,0 Z M 1,1 9,1 9,9 1,9 Z" /></svg>
      </button>
      <button id="close-btn" class="title-bar-button" aria-label="å…³é—­">
        <svg aria-hidden="true" version="1.1" width="10" height="10"><path d="M 0,0 0,0.7 4.3,5 0,9.3 0,10 0.7,10 5,5.7 9.3,10 10,10 10,9.3 5.7,5 10,0.7 10,0 9.3,0 5,4.3 0.7,0 Z" /></svg>
      </button>
    </div>
  </div>
  <div class="app-layout">
    <aside class="sidebar">
      <div class="sidebar-header">
        <h2>åŠŸèƒ½å¯¼èˆª</h2>
      </div>
      <nav>
        <ul>
          <li><a href="#" class="nav-link active" data-view="sheinLabelView">Shein Label ç”Ÿæˆ</a></li>
          <li><a href="#" class="nav-link" data-view="pdfResizeView">PDF å°ºå¯¸è°ƒæ•´</a></li>
        </ul>
      </nav>
      <div id="themeToggleSwitch" class="theme-switch-wrapper" title="åˆ‡æ¢ä¸»é¢˜">
        <div class="theme-switch-track">
          <div class="theme-switch-thumb">
            <span class="sun-icon">â˜€ï¸</span>
            <span class="moon-icon">ğŸŒ™</span>
          </div>
        </div>
      </div>
    </aside>

    <main class="main-content">
      <div class="view-container" id="pdfResizeView" style="display: none;">
        <!-- Existing content will be wrapped by its own .container if needed, or styled directly -->
        <div class="container"> <!-- This is the original .container -->
          <div class="title-with-description">
            <h2>PDF å°ºå¯¸è°ƒæ•´</h2>
            <span class="feature-description">è°ƒæ•´æ‰€é€‰ PDF æ–‡ä»¶çš„é¡µé¢å°ºå¯¸ï¼Œæ”¯æŒé¢„è®¾å°ºå¯¸å’Œè‡ªå®šä¹‰å°ºå¯¸ã€‚</span>
          </div>
          
          <div class="section">
            <div class="field-wrapper"> <!-- Added wrapper for layout with error message -->
              <button id="openFile" class="btn-primary">é€‰æ‹© PDF æ–‡ä»¶</button>
              <span id="selectedFile" class="file-select-status-span"></span>
              <span class="field-hint">å¾…è°ƒæ•´å°ºå¯¸çš„PDF</span>
              <small class="error-message" id="selectedFileError"></small> <!-- New error message placeholder -->
            </div>
          </div>
      
          <div class="section">
            <label for="pdfResizeOutputName">æ–‡ä»¶åç§° <span class="field-hint">è¾“å‡ºæ–‡ä»¶å,ä¸å«æ‰©å±•å</span></label>
            <input type="text" id="pdfResizeOutputName" placeholder="ä¾‹å¦‚: resized_document">
          </div>
      
          <div class="section">
            <label for="pageSize">é¡µé¢å°ºå¯¸ <span class="field-hint">é€‰æ‹©é¢„è®¾æˆ–è‡ªå®šä¹‰</span></label>
            <div class="custom-select-wrapper">
              <select id="pageSize" style="display:none;">
                <option value="A4">A4 (210x297mm)</option>
                <option value="Letter">Letter (215.9x279.4mm)</option>
                <option value="Shein" selected>Shein (70x60mm)</option>
                <option value="custom">è‡ªå®šä¹‰</option>
              </select>
              <div class="custom-select-container" id="customPageSizeSelect">
                <div class="custom-select-trigger"><span>Shein (70x60mm)</span><div class="arrow"></div></div>
                <div class="custom-select-options">
                  {/* Options will be populated by JS */}
                </div>
              </div>
            </div>
            <div id="customSize" class="dimension-inputs-container" style="display: none;">
              <div class="field-wrapper">
                <div class="input-group">
                  <input type="number" id="customWidth" placeholder="å®½åº¦">
                  <span class="unit">mm</span>
                </div>
                <span class="field-hint">è‡ªå®šä¹‰å®½åº¦,æ¯«ç±³</span>
                <small class="error-message" id="customWidthError"></small>
              </div>
              <div class="field-wrapper">
                <div class="input-group">
                  <input type="number" id="customHeight" placeholder="é«˜åº¦">
                  <span class="unit">mm</span>
                </div>
                <span class="field-hint">è‡ªå®šä¹‰é«˜åº¦,æ¯«ç±³</span>
                <small class="error-message" id="customHeightError"></small>
              </div>
            </div>
          </div>
      
          <div class="action-buttons-row" style="display: flex; margin-bottom: 10px;">
            <button id="processBtn" class="btn-primary">å¼€å§‹å¤„ç†</button> <!-- Removed flex-grow: 1 -->
            <button id="clearPdfResizeFormBtn" class="btn-secondary" style="margin-left: 10px;">æ¸…ç©º</button>
          </div>
          <div id="result"></div>
<div id="pdfResizePostProcessActions" style="margin-top: 10px; display: none;">
            <button id="pdfResizeOpenGeneratedFileBtn" class="action-button">æ‰“å¼€æ–‡ä»¶</button>
            <button id="pdfResizeShowGeneratedFileInFolderBtn" class="action-button">æ‰“å¼€æ–‡ä»¶å¤¹</button>
            <button id="pdfResizeCopyFileBtn" class="action-button" title="å°è¯•å¤åˆ¶æ–‡ä»¶åˆ°å‰ªè´´æ¿ (è‹¥å¤±è´¥åˆ™å¤åˆ¶è·¯å¾„)">å¤åˆ¶æ–‡ä»¶</button>
          </div>
        </div>
      </div>

      <div class="view-container" id="sheinLabelView" style="display: block;">
        <div class="container"> <!-- Each view can have its own container for consistency -->
          <div class="title-with-description">
            <h2>Shein Label ç”Ÿæˆ</h2>
            <span class="feature-description">åˆå¹¶æ¬§ä»£å’Œæ¡ç  PDFï¼Œç”Ÿæˆç¬¦åˆ Shein è¦æ±‚çš„æ ‡ç­¾ã€‚</span>
          </div>
          
          <div class="section">
            <div class="field-wrapper"> <!-- Added wrapper -->
              <button id="sheinOpenFile1Btn" class="btn-primary">é€‰æ‹©æ¬§ä»£æ–‡ä»¶</button>
              <span id="sheinSelectedFile1" class="file-select-status-span">æœªé€‰æ‹©æ–‡ä»¶</span>
              <span class="field-hint">æ¬§ä»£PDFæ–‡ä»¶</span>
              <small class="error-message" id="sheinSelectedFile1Error"></small> <!-- New error message placeholder -->
            </div>
          </div>

          <div class="section">
            <div class="field-wrapper"> <!-- Added wrapper -->
              <button id="sheinOpenFile2Btn" class="btn-primary">é€‰æ‹©æ¡ç æ–‡ä»¶</button>
              <span id="sheinSelectedFile2" class="file-select-status-span">æœªé€‰æ‹©æ–‡ä»¶</span>
              <span class="field-hint">æ¡ç PDFæ–‡ä»¶</span>
              <small class="error-message" id="sheinSelectedFile2Error"></small> <!-- New error message placeholder -->
            </div>
          </div>

          <div class="section">
            <label for="sheinOutputName">æ–‡ä»¶åç§° <span class="field-hint">Sheinæ ‡ç­¾è¾“å‡ºæ–‡ä»¶å</span></label>
            <input type="text" id="sheinOutputName" placeholder="ä¾‹å¦‚: shein_label_output">
          </div>

          <div class="section">
            <label for="sheinOutputPageSize">é¡µé¢å°ºå¯¸ <span class="field-hint">Sheinæ ‡ç­¾è¾“å‡ºå°ºå¯¸</span></label>
            <div class="custom-select-wrapper">
              <select id="sheinOutputPageSize" style="display:none;">
                <option value="A4">A4 (210x297mm)</option>
                <option value="Letter">Letter (215.9x279.4mm)</option>
                <option value="Shein" selected>Shein (70x60mm)</option>
                <option value="custom">è‡ªå®šä¹‰</option>
              </select>
              <div class="custom-select-container" id="customSheinOutputPageSizeSelect">
                <div class="custom-select-trigger"><span>Shein (70x60mm)</span><div class="arrow"></div></div>
                <div class="custom-select-options">
                  {/* Options will be populated by JS */}
                </div>
              </div>
            </div>
            <div id="sheinOutputCustomDimensions" class="dimension-inputs-container" style="display: none;">
              <div class="field-wrapper">
                <div class="input-group">
                  <input type="number" id="sheinOutputWidth" placeholder="å®½åº¦" value="70">
                  <span class="unit">mm</span>
                </div>
                <span class="field-hint">æ ‡ç­¾å®½åº¦,æ¯«ç±³</span>
                <small class="error-message" id="sheinOutputWidthError"></small>
              </div>
              <div class="field-wrapper">
                <div class="input-group">
                  <input type="number" id="sheinOutputHeight" placeholder="é«˜åº¦" value="60">
                  <span class="unit">mm</span>
                </div>
                <span class="field-hint">æ ‡ç­¾é«˜åº¦,æ¯«ç±³</span>
                <small class="error-message" id="sheinOutputHeightError"></small>
              </div>
            </div>
          </div>

          <div class="action-buttons-row" style="display: flex; margin-bottom: 10px;">
            <button id="generateSheinLabelBtn" class="btn-primary">ç”Ÿæˆ Shein Label</button> <!-- Removed flex-grow: 1 -->
            <button id="clearSheinLabelFormBtn" class="btn-secondary" style="margin-left: 10px;">æ¸…ç©º</button>
          </div>
          <div id="sheinResult"></div>
          <div id="sheinPostProcessActions" style="margin-top: 10px; display: none;">
            <button id="openGeneratedFileBtn" class="action-button">æ‰“å¼€æ–‡ä»¶</button>
            <button id="showGeneratedFileInFolderBtn" class="action-button">æ‰“å¼€æ–‡ä»¶å¤¹</button>
            <button id="sheinCopyFileBtn" class="action-button" title="å°è¯•å¤åˆ¶æ–‡ä»¶åˆ°å‰ªè´´æ¿ (è‹¥å¤±è´¥åˆ™å¤åˆ¶è·¯å¾„)">å¤åˆ¶æ–‡ä»¶</button>
          </div>
        </div>
      </div>
    </main>
  </div>

  <!-- <script src="renderer.js"></script> -->
  <script>
  document.addEventListener('DOMContentLoaded', () => {
    // --- Settings Persistence using Electron IPC ---
    // Note: saveToLocalStorage and loadFromLocalStorage are removed.
    // We will use window.electronAPI.getSettings() and window.electronAPI.saveSettings()

    let appSettings = {}; // Holds all application settings

    // --- Sidebar navigation and View Persistence ---
    const navLinks = document.querySelectorAll('.sidebar .nav-link');
    const views = document.querySelectorAll('.main-content .view-container');
    const defaultViewId = 'sheinLabelView';

    // Function to activate a view and save it
    const activateView = async (viewId) => {
      let viewActivated = false;
      views.forEach(view => {
        if (view.id === viewId) {
          view.style.display = 'block';
          viewActivated = true;
        } else {
          view.style.display = 'none';
        }
      });

      navLinks.forEach(l => {
        if (l.getAttribute('data-view') === viewId) {
          l.classList.add('active');
        } else {
          l.classList.remove('active');
        }
      });

      if (viewActivated) {
        appSettings.activeView = viewId;
        await window.electronAPI.saveSettings(appSettings);
      }
      return viewActivated;
    };
    
    navLinks.forEach(link => {
      link.addEventListener('click', async function(event) { // Made async
        event.preventDefault();
        const viewId = this.getAttribute('data-view');
        await activateView(viewId); // Made await
      });
    });

    // Helper function to get basename using pure JavaScript (as a fallback)
    function getBasenameFrontend(filePath) {
      if (!filePath || typeof filePath !== 'string') {
        return '';
      }
      // Replace all backslashes with forward slashes for consistent parsing
      const normalizedPath = filePath.replace(/\\/g, '/');
      const lastSlashIndex = normalizedPath.lastIndexOf('/');
      if (lastSlashIndex === -1) {
        return normalizedPath; // No slashes, the whole path is the filename
      }
      return normalizedPath.substring(lastSlashIndex + 1);
    }

    function getFilenameWithoutExtension(filePath) {
      if (!filePath || typeof filePath !== 'string') {
        return '';
      }
      const basename = getBasenameFrontend(filePath);
      const lastDotIndex = basename.lastIndexOf('.');
      if (lastDotIndex === -1) {
        return basename; // No extension
      }
      return basename.substring(0, lastDotIndex);
    }

    function getCurrentHHMMSS() {
      const now = new Date();
      const hours = String(now.getHours()).padStart(2, '0');
      const minutes = String(now.getMinutes()).padStart(2, '0');
      const seconds = String(now.getSeconds()).padStart(2, '0');
      return `${hours}${minutes}${seconds}`;
    }

    // Function to get the output filename suffix for PDF Resize based on selected/custom dimensions
    function getOutputSuffixForPdfResize() {
      const pageSizeSelect = document.getElementById('pageSize');
      const customWidthInput = document.getElementById('customWidth');
      const customHeightInput = document.getElementById('customHeight');

      if (!pageSizeSelect) return '_å°ºå¯¸ä¿®æ”¹_æœªçŸ¥å°ºå¯¸'; // Fallback

      const selectedPageSizeValue = pageSizeSelect.value;
      let width = '';
      let height = '';

      if (selectedPageSizeValue === 'custom') {
        width = customWidthInput ? customWidthInput.value.trim() : '';
        height = customHeightInput ? customHeightInput.value.trim() : '';
        if (width && height && !isNaN(parseFloat(width)) && parseFloat(width) > 0 && !isNaN(parseFloat(height)) && parseFloat(height) > 0) {
          return `_å°ºå¯¸ä¿®æ”¹_${parseFloat(width)}x${parseFloat(height)}`;
        } else {
          return '_å°ºå¯¸ä¿®æ”¹_è‡ªå®šä¹‰'; // Or some other indicator of custom but invalid/incomplete
        }
      } else {
        const presetDimensions = pageSizeMapMM[selectedPageSizeValue]; // pageSizeMapMM should be defined
        if (presetDimensions) {
          return `_å°ºå¯¸ä¿®æ”¹_${presetDimensions.width}x${presetDimensions.height}`;
        }
      }
      return '_å°ºå¯¸ä¿®æ”¹_é¢„è®¾'; // Fallback for unknown preset
    }

    function formatBytes(bytes, decimals = 2) {
      if (bytes === null || bytes === undefined || isNaN(parseFloat(bytes)) || !isFinite(bytes) || bytes === 0) return '0 Bytes';
      const k = 1024;
      const dm = decimals < 0 ? 0 : decimals;
      const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'];
      const i = Math.floor(Math.log(bytes) / Math.log(k));
      return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
    }

    function updateFileSelectionUI(filePath, spanElementId, pageCount = null, fileSize = null, isLoadingMetadata = false) {
      const spanElement = document.getElementById(spanElementId);
      if (!spanElement) return;

      if (filePath && typeof filePath === 'string' && filePath.trim() !== '') {
        let displayText = getBasenameFrontend(filePath);
        if (isLoadingMetadata) {
          displayText += ' (æ­£åœ¨è·å–ä¿¡æ¯...)';
        } else {
          let details = [];
          if (pageCount !== null && pageCount !== undefined) {
            details.push(`é¡µæ•°: ${pageCount}`);
          }
          if (fileSize !== null && fileSize !== undefined) {
            details.push(`å¤§å°: ${formatBytes(fileSize)}`);
          }
          if (details.length > 0) {
            displayText += ` (${details.join(', ')})`;
          }
        }
        spanElement.textContent = displayText;
        spanElement.classList.add('file-selected-badge');
      } else {
        spanElement.textContent = 'æœªé€‰æ‹©æ–‡ä»¶';
        spanElement.classList.remove('file-selected-badge');
      }
    }
// Function to validate filename against Windows and macOS restricted characters
    function isValidFilename(filename) {
      if (!filename || typeof filename !== 'string') {
        return { valid: true };
      }
      // Windows reserved characters (including / which is also for macOS)
      // eslint-disable-next-line no-control-regex
      const windowsReservedChars = /[<>;:"/\\|?*\x00-\x1F]/g;
      // macOS reserved characters (colon is already in windowsReservedChars, / is also covered)
      // Technically, macOS only forbids ':' and '/', but '/' is path separator everywhere.
      // For simplicity and broader compatibility, we'll stick to the Windows set as it's more restrictive.

      if (windowsReservedChars.test(filename)) {
        return { valid: false, message: 'æ–‡ä»¶ååŒ…å«æ— æ•ˆå­—ç¬¦ (ä¾‹å¦‚: &lt; &gt; : " / \\ | ? *)ã€‚è¯·ç§»é™¤è¿™äº›å­—ç¬¦ã€‚' };
      }

      // Windows reserved filenames (case-insensitive)
      const reservedNames = /^(CON|PRN|AUX|NUL|COM[1-9]|LPT[1-9])$/i;
      // Remove extension before checking reserved names
      const nameWithoutExtension = filename.includes('.') ? filename.substring(0, filename.lastIndexOf('.')) : filename;
      if (reservedNames.test(nameWithoutExtension)) {
        return { valid: false, message: 'æ–‡ä»¶åæ˜¯ç³»ç»Ÿä¿ç•™åç§° (ä¾‹å¦‚: CON, PRN, AUX, NUL, COM1-9, LPT1-9)ã€‚è¯·è¾“å…¥å…¶ä»–åç§°ã€‚' };
      }

      if (filename.startsWith(' ') || filename.endsWith(' ') || filename.endsWith('.')) {
        return { valid: false, message: 'æ–‡ä»¶åä¸èƒ½ä»¥ç©ºæ ¼å¼€å¤´æˆ–ç»“å°¾ï¼Œä¹Ÿä¸èƒ½ä»¥ç‚¹å·ç»“å°¾ã€‚' };
      }
      
      if (filename.length > 255) { // Common file system limit
        return { valid: false, message: 'æ–‡ä»¶åè¿‡é•¿ (æœ€å¤š255ä¸ªå­—ç¬¦)ã€‚' };
      }

      return { valid: true, message: '' };
    }
    
    // Function to clear specific inline error associated with a file input
    function clearInlineFileError(errorElementId) {
        const errorEl = document.getElementById(errorElementId);
        if (errorEl) {
            errorEl.textContent = '';
            errorEl.style.display = 'none';
            errorEl.classList.remove('warning-text'); // Remove warning class if it was added
        }
    }


    // Custom Title Bar Logic
    const minimizeBtn = document.getElementById('minimize-btn');
    const maximizeRestoreBtn = document.getElementById('maximize-restore-btn');
    const closeBtn = document.getElementById('close-btn');

    if (minimizeBtn) {
      minimizeBtn.addEventListener('click', () => {
        if (window.electronAPI && typeof window.electronAPI.minimizeWindow === 'function') {
          window.electronAPI.minimizeWindow();
        }
      });
    }

    if (maximizeRestoreBtn) {
      maximizeRestoreBtn.addEventListener('click', () => {
        if (window.electronAPI && typeof window.electronAPI.maximizeRestoreWindow === 'function') {
          window.electronAPI.maximizeRestoreWindow();
        }
      });
    }

    if (closeBtn) {
      closeBtn.addEventListener('click', () => {
        if (window.electronAPI && typeof window.electronAPI.closeWindow === 'function') {
          window.electronAPI.closeWindow();
        }
      });
    }

    // Update maximize/restore button icon based on window state
    const maximizeIcon = '<svg aria-hidden="true" version="1.1" width="10" height="10"><path d="M 0,0 0,10 10,10 10,0 Z M 1,1 9,1 9,9 1,9 Z" /></svg>';
    const restoreIcon = '<svg aria-hidden="true" version="1.1" width="10" height="10"><path d="m 2,1e-5 0,2 -2,0 0,8 8,0 0,-2 2,0 0,-8 z m 1,1 6,0 0,6 -1,0 0,-5 -5,0 z m -2,2 6,0 0,6 -6,0 z" /></svg>';

    if (window.electronAPI && typeof window.electronAPI.onWindowMaximized === 'function') {
      window.electronAPI.onWindowMaximized(() => {
        if (maximizeRestoreBtn) {
          maximizeRestoreBtn.innerHTML = restoreIcon;
          maximizeRestoreBtn.setAttribute('aria-label', 'è¿˜åŸ');
        }
      });
    }

    if (window.electronAPI && typeof window.electronAPI.onWindowUnmaximized === 'function') {
      window.electronAPI.onWindowUnmaximized(() => {
        if (maximizeRestoreBtn) {
          maximizeRestoreBtn.innerHTML = maximizeIcon;
          maximizeRestoreBtn.setAttribute('aria-label', 'æœ€å¤§åŒ–');
        }
      });
    }
    // End Custom Title Bar Logic

    const themeToggleSwitch = document.getElementById('themeToggleSwitch');

    async function setTheme(theme, save = true) { // Added save parameter
      const isDark = theme === 'dark';
      document.body.classList.toggle('dark-mode', isDark);
      themeToggleSwitch.classList.toggle('active', isDark);

      if (save) {
        appSettings.theme = theme;
        await window.electronAPI.saveSettings(appSettings);
      }
    }

    themeToggleSwitch.addEventListener('click', async () => {
      const newTheme = document.body.classList.contains('dark-mode') ? 'light' : 'dark';
      await setTheme(newTheme);
    });

    // Function to show toast notifications
    function showToast(message, type = 'info', duration = 3500) {
      const container = document.getElementById('toastContainer');
      if (!container) {
        console.error('Toast container not found!');
        return;
      }

      const toast = document.createElement('div');
      toast.className = `toast toast-${type}`; // e.g., "toast toast-success"
    
      // --- Add logging and default message for debugging ---
      console.log(`showToast called with message: "${message}", type: "${type}"`);
      const displayMessage = (message && typeof message === 'string' && message.trim() !== '') ? message : "[é»˜è®¤æµ‹è¯•æç¤º]";
      toast.textContent = displayMessage;
      // --- End of debugging addition ---
    
      container.appendChild(toast);

      // Remove the toast after its animation finishes
      // The 'duration' parameter (default 3500ms) is how long the toast stays fully visible
      // before starting to fade out.
      const fadeOutAnimationDuration = 400; // Must match the CSS animation duration for .fade-out (0.4s)

      setTimeout(() => {
        toast.classList.add('fade-out'); // Add class to trigger CSS fade-out animation

        // Remove the toast from DOM after the fade-out animation completes
        setTimeout(() => {
          if (toast.parentNode === container) {
            container.removeChild(toast);
          }
        }, fadeOutAnimationDuration);
      }, duration); // 'duration' is when the fade-out should start
    }

    // --- Standardized Error Handling for Toasts ---
    /**
     * Handles API errors and displays a standardized toast message.
     * @param {object} apiResult - The result object from an API call, expected to have an 'error' property if failed.
     * @param {string} featureName - The name of the feature where the error occurred (e.g., "PDFå°ºå¯¸è°ƒæ•´").
     * @param {string} [defaultApiErrorMsg='æ“ä½œå¤±è´¥ã€‚è¯·æ£€æŸ¥æ–‡ä»¶æˆ–è®¾ç½®ï¼Œç„¶åé‡è¯•ã€‚'] - Default message if apiResult.error is not specific.
     * @param {HTMLElement|null} [resultDiv=null] - Optional result div to clear/hide.
     * @param {HTMLElement|null} [postProcessActionsDiv=null] - Optional post-process actions div to hide.
     */
    function handleAndShowApiError(apiResult, featureName, defaultApiErrorMsg = 'æ“ä½œå¤±è´¥ã€‚è¯·æ£€æŸ¥æ–‡ä»¶æˆ–è®¾ç½®ï¼Œç„¶åé‡è¯•ã€‚', resultDiv = null, postProcessActionsDiv = null) {
      const errorMessage = (apiResult && apiResult.error) ? apiResult.error : defaultApiErrorMsg;
      showToast(`${featureName}å¤±è´¥ï¼š${errorMessage}`, 'error');
      if (resultDiv) {
        resultDiv.innerHTML = '';
        resultDiv.style.display = 'none';
        resultDiv.className = '';
      }
      if (postProcessActionsDiv) {
        postProcessActionsDiv.style.display = 'none';
      }
    }

    /**
     * Handles client-side JavaScript errors and displays a standardized toast message.
     * @param {Error} errorObject - The JavaScript Error object.
     * @param {string} featureName - The name of the feature where the error occurred.
     * @param {string} [defaultClientErrorMsg='å®¢æˆ·ç«¯å‘ç”Ÿæ„å¤–é”™è¯¯ï¼Œè¯·é‡è¯•ã€‚'] - Default message if errorObject.message is not specific.
     * @param {HTMLElement|null} [resultDiv=null] - Optional result div to clear/hide and show client error.
     * @param {HTMLElement|null} [postProcessActionsDiv=null] - Optional post-process actions div to hide.
     */
    function handleAndShowClientError(errorObject, featureName, defaultClientErrorMsg = 'å®¢æˆ·ç«¯å‘ç”Ÿæ„å¤–é”™è¯¯ï¼Œè¯·é‡è¯•ã€‚', resultDiv = null, postProcessActionsDiv = null) {
      const errorMessage = errorObject.message ? errorObject.message : defaultClientErrorMsg;
      showToast(`${featureName}å‡ºé”™ï¼š${errorMessage}`, 'error');
      if (resultDiv) {
        resultDiv.innerHTML = `<p>å®¢æˆ·ç«¯é”™è¯¯: ${errorMessage}</p>`;
        resultDiv.className = 'error';
        resultDiv.style.display = 'block';
      }
      if (postProcessActionsDiv) {
        postProcessActionsDiv.style.display = 'none';
      }
    }
    // --- End Standardized Error Handling ---

    // --- Listener for Toasts from Main Process ---
    if (window.electronAPI && typeof window.electronAPI.onShowToast === 'function') {
      window.electronAPI.onShowToast((message, type, duration) => {
        showToast(message, type, duration);
      });
    } else {
      console.error('Error: window.electronAPI.onShowToast is not available. Toasts from main process will not be shown.');
    }
    // --- End Listener for Toasts from Main Process ---

    // For PDF Resize View Post-Process Actions
    const pdfResizePostProcessActionsDiv = document.getElementById('pdfResizePostProcessActions');
    const pdfResizeOpenGeneratedFileBtn = document.getElementById('pdfResizeOpenGeneratedFileBtn');
    const pdfResizeShowGeneratedFileInFolderBtn = document.getElementById('pdfResizeShowGeneratedFileInFolderBtn');
    const pdfResizeCopyFileBtn = document.getElementById('pdfResizeCopyFileBtn');
    let currentGeneratedPdfResizePath = ''; // To store the path for these buttons

    const pageSizeMap = {
      'A4': { width: 210 * 2.835, height: 297 * 2.835 }, // mmè½¬pt
      'Letter': { width: 215.9 * 2.835, height: 279.4 * 2.835 },
      'Shein': { width: 70 * 2.835, height: 60 * 2.835 }, // mmè½¬pt
      'custom': null
    }

    const pageSizeMapMM = { // For populating MM inputs
      'A4': { width: 210, height: 297 },
      'Letter': { width: 215.9, height: 279.4 },
      'Shein': { width: 70, height: 60 }
    };

    let selectedFilePath = ''

    document.getElementById('openFile').addEventListener('click', async () => {
      const newPath = await window.electronAPI.openFile();
      const selectedFileErrorEl = document.getElementById('selectedFileError');
      const openFileButton = document.getElementById('openFile');

      if (!newPath) {
        showToast('æ“ä½œå·²å–æ¶ˆã€‚', 'info');
        // If a file was previously selected, and now cancelled, selectedFilePath might still hold old path.
        // We should update UI to "æœªé€‰æ‹©æ–‡ä»¶" if cancellation truly means no file.
        // If selectedFilePath is already empty or user cancels, updateFileSelectionUI will handle it.
        // No specific metadata fetch needed if no new path.
        // updateFileSelectionUI(selectedFilePath, 'selectedFile'); // Update with current selectedFilePath (might be old or empty)
      } else {
        selectedFilePath = newPath;
        appSettings.pdfResizeSelectedPath = selectedFilePath;
        // Immediately update UI to show filename and loading state
        updateFileSelectionUI(selectedFilePath, 'selectedFile', null, null, true);

        try {
          const metadata = await window.electronAPI.getPdfMetadata(selectedFilePath);
          // Now update with full metadata
          if (metadata.success) {
            updateFileSelectionUI(selectedFilePath, 'selectedFile', metadata.pageCount, metadata.size, false);
            if (openFileButton) openFileButton.classList.remove('input-error');
            if (selectedFileErrorEl) {
                selectedFileErrorEl.textContent = '';
                selectedFileErrorEl.style.display = 'none';
            }
          } else {
            showToast(`æ— æ³•è¯»å–æ–‡ä»¶å…ƒæ•°æ®: ${metadata.error || 'æœªçŸ¥é”™è¯¯'}`, 'error');
            updateFileSelectionUI(selectedFilePath, 'selectedFile', null, null, false); // Show filename at least, remove loading
          }
        } catch (err) {
          showToast(`è·å–æ–‡ä»¶å…ƒæ•°æ®æ—¶å‡ºé”™: ${err.message}`, 'error');
          updateFileSelectionUI(selectedFilePath, 'selectedFile', null, null, false); // Show filename at least, remove loading
        }

        // Auto-fill output name for PDF Resize
        const pdfResizeOutputNameInput = document.getElementById('pdfResizeOutputName');
        if (pdfResizeOutputNameInput) {
          const baseNameNoExt = getFilenameWithoutExtension(selectedFilePath);
          const suffix = getOutputSuffixForPdfResize(); // Use new function
          const newOutputName = `${baseNameNoExt}${suffix}`; // No .pdf here
          pdfResizeOutputNameInput.value = newOutputName;
          // Trigger input event for live validation and settings saving
          const inputEvent = new Event('input', { bubbles: true });
          pdfResizeOutputNameInput.dispatchEvent(inputEvent);
        }

        const saveResult = await window.electronAPI.saveSettings(appSettings); // Save other settings like selected path
        if (!saveResult || !saveResult.success) {
          console.error('Failed to save settings after PDF Resize file selection:', saveResult ? saveResult.error : 'Unknown error');
          showToast('è­¦å‘Šï¼šæ— æ³•ä¿å­˜æ–‡ä»¶é€‰æ‹©è®¾ç½®ã€‚', 'warning');
        }
      }
      // If newPath is null (cancelled), selectedFilePath might still hold the previous value.
      // The UI update for "æœªé€‰æ‹©æ–‡ä»¶" is handled by updateFileSelectionUI if selectedFilePath becomes empty.
      // If user cancels, and selectedFilePath was already empty, updateFileSelectionUI will show "æœªé€‰æ‹©æ–‡ä»¶".
      // If user cancels, and selectedFilePath had a value, it will still show that old file's info
      // unless we explicitly clear selectedFilePath here on cancel.
      // For now, let's assume cancelling means "keep the last valid selection or show 'æœªé€‰æ‹©æ–‡ä»¶' if none".
      // The error clearing logic for the button itself is handled above if a new file is successfully processed.
    })

    // Initialize the badge state on load - this will be handled by loadAndApplySettings
    // const initialSelectedFileElement = document.getElementById('selectedFile');
    // if (!selectedFilePath) {
    //     initialSelectedFileElement.textContent = 'æœªé€‰æ‹©æ–‡ä»¶';
    //     initialSelectedFileElement.classList.remove('file-selected-badge');
    // }


    // Function to update PDF resize output name based on current selections
    function updatePdfResizeOutputNameBasedOnSelections() {
      if (selectedFilePath) { // Only update if a file is selected
        const pdfResizeOutputNameInput = document.getElementById('pdfResizeOutputName');
        if (pdfResizeOutputNameInput) {
          const baseNameNoExt = getFilenameWithoutExtension(selectedFilePath);
          const suffix = getOutputSuffixForPdfResize();
          const newOutputName = `${baseNameNoExt}${suffix}`;
          pdfResizeOutputNameInput.value = newOutputName;
          // Trigger input event for live validation and settings saving
          const inputEvent = new Event('input', { bubbles: true });
          pdfResizeOutputNameInput.dispatchEvent(inputEvent);
        }
      }
    }

    document.getElementById('pageSize').addEventListener('change', async function() { // Added async
      const customSizeEl = document.getElementById('customSize');
      if (this.value === 'custom') {
        customSizeEl.style.display = 'flex'; // Ensure it's flex for layout
      } else {
        customSizeEl.style.display = 'none';
      }
      appSettings.pageSize = this.value;
      await window.electronAPI.saveSettings(appSettings);
      updatePdfResizeOutputNameBasedOnSelections(); // Update output name on page size change
    })
    // Ensure sheinOutputCustomSize is flex by default if it's always visible
    // Or add a similar JS logic if it needs to be toggled. For now, CSS will handle it.

    // Add event listeners to custom dimension inputs for PDF Resize
    const customWidthInput = document.getElementById('customWidth');
    const customHeightInput = document.getElementById('customHeight');
    const customWidthErrorEl = document.getElementById('customWidthError');
    const customHeightErrorEl = document.getElementById('customHeightError');

    if (customWidthInput && customWidthErrorEl) {
      customWidthInput.addEventListener('input', () => {
        const widthVal = parseFloat(customWidthInput.value);
        if (!isNaN(widthVal) && widthVal > 0) {
          customWidthInput.classList.remove('input-error');
          customWidthErrorEl.textContent = '';
          customWidthErrorEl.style.display = 'none';
        }
        updatePdfResizeOutputNameBasedOnSelections(); // Update output name on custom width change
      });
   }

   if (customHeightInput && customHeightErrorEl) {
     customHeightInput.addEventListener('input', () => {
       const heightVal = parseFloat(customHeightInput.value);
       if (!isNaN(heightVal) && heightVal > 0) {
         customHeightInput.classList.remove('input-error');
         customHeightErrorEl.textContent = '';
         customHeightErrorEl.style.display = 'none';
       }
       updatePdfResizeOutputNameBasedOnSelections(); // Update output name on custom height change
     });
   }

    // Add input event listener for pdfResizeOutputName to clear error on valid input
    const pdfResizeOutputNameInputForLiveValidation = document.getElementById('pdfResizeOutputName');
    if (pdfResizeOutputNameInputForLiveValidation) {
      pdfResizeOutputNameInputForLiveValidation.addEventListener('input', function() {
        // Construct a temporary full filename if it doesn't end with .pdf for validation purposes
        let tempOutputName = this.value.trim();
        if (tempOutputName && !tempOutputName.toLowerCase().endsWith('.pdf')) {
          // We don't append .pdf here for live validation,
          // as the user might be typing the extension or it might be optional until submission.
          // The main validation on submit handles adding .pdf if missing.
          // isValidFilename should handle names with or without extensions correctly.
        }
        const validation = isValidFilename(tempOutputName);
        if (validation.valid) {
          this.classList.remove('input-error');
        }
        // We don't add 'input-error' here, as that's handled on submit.
        // This listener is only for clearing the error.
      });
    }

    document.getElementById('processBtn').addEventListener('click', async () => {
      const processButton = document.getElementById('processBtn');
      const originalButtonText = processButton.textContent;
      let timerInterval; // Declare timerInterval outside try block

      try {
        // Resetting file selection error state (done after global resultDiv reset and before other specific resets)
        // This will be handled by the more general reset block below.

        if (!selectedFilePath) {
        const openFileButton = document.getElementById('openFile');
        const selectedFileErrorEl = document.getElementById('selectedFileError');

        if (openFileButton) {
            openFileButton.classList.add('input-error');
            // Optionally focus the button, though it might be disruptive
            // openFileButton.focus();
        }
        const errorMessage = 'è¯·å…ˆé€‰æ‹©ä¸€ä¸ª PDF æ–‡ä»¶ã€‚';
        showToast(errorMessage, 'error'); // Added toast notification
        if (selectedFileErrorEl) {
            selectedFileErrorEl.textContent = errorMessage;
            selectedFileErrorEl.style.display = 'block';
        } else {
            // Fallback if the error element itself is somehow missing
            console.error("PDF Resize Error: selectedFileError element not found in DOM!");
            // Toast already shown, so no need for resultDiv fallback for this specific message
        }
        // Ensure button is reset if validation fails early
        if (processButton) {
            processButton.disabled = false;
            processButton.textContent = originalButtonText;
            processButton.classList.remove('processing');
        }
        // No timer should be active here yet, but good practice if logic changes
        if (timerInterval) clearInterval(timerInterval);
        return;
      }
 
      const operations = {}
      const pdfResizeOutputNameInput = document.getElementById('pdfResizeOutputName');

      // Reset/hide post-process actions for pdfResizeView at the start of processing
      if (pdfResizePostProcessActionsDiv) {
          pdfResizePostProcessActionsDiv.style.display = 'none';
      }
      currentGeneratedPdfResizePath = '';
      const resultDivForReset = document.getElementById('result'); // Global result div
      if (resultDivForReset) {
          resultDivForReset.innerHTML = '';
          resultDivForReset.className = '';
          resultDivForReset.style.display = 'none'; // Hide global result div when resetting
      }
      // Also reset custom dimension inline errors here if they were shown from a previous attempt
      const widthInputForReset = document.getElementById('customWidth');
      const heightInputForReset = document.getElementById('customHeight');
      const customWidthErrorElForReset = document.getElementById('customWidthError');
      const customHeightErrorElForReset = document.getElementById('customHeightError');

      if (widthInputForReset && customWidthErrorElForReset) {
          widthInputForReset.classList.remove('input-error');
          customWidthErrorElForReset.textContent = '';
          customWidthErrorElForReset.style.display = 'none';
      }
      if (heightInputForReset && customHeightErrorElForReset) {
          heightInputForReset.classList.remove('input-error');
          customHeightErrorElForReset.textContent = '';
          customHeightErrorElForReset.style.display = 'none';
      }
      // Also reset file selection error state here
      const openFileButtonForReset = document.getElementById('openFile');
      const selectedFileErrorForReset = document.getElementById('selectedFileError');
      if (openFileButtonForReset && selectedFileErrorForReset) {
          openFileButtonForReset.classList.remove('input-error');
          selectedFileErrorForReset.textContent = '';
          selectedFileErrorForReset.style.display = 'none';
      }

      // getCurrentHHMMSS is now a global helper function

      let outputName = pdfResizeOutputNameInput.value.trim();
      // Auto-generation of outputName if empty is now handled by file selection,
      // but keep this as a fallback if user clears it and then clicks process.
      if (!outputName) {
        const base = selectedFilePath ? getFilenameWithoutExtension(selectedFilePath) : 'resized_file';
        const suffix = selectedFilePath ? getOutputSuffixForPdfResize() : `_å°ºå¯¸ä¿®æ”¹_${getCurrentHHMMSS()}`; // Fallback suffix if no file selected
        outputName = `${base}${suffix}`; // No .pdf here
        // pdfResizeOutputNameInput.value = outputName; // Optionally update the input if it was empty
      }

      // Validate the name part without .pdf
      const filenameValidation = isValidFilename(outputName);
      if (!filenameValidation.valid) {
        showToast(filenameValidation.message, 'error');
        // Optionally, highlight the input field
        if (pdfResizeOutputNameInput) {
          pdfResizeOutputNameInput.classList.add('input-error');
          pdfResizeOutputNameInput.focus();
        }
        // Restore button state if validation fails before processing starts
        if (processButton) {
            processButton.disabled = false;
            processButton.textContent = originalButtonText;
            processButton.classList.remove('processing');
        }
        // timerInterval should be cleared here as per the logic
        if (timerInterval) clearInterval(timerInterval);
        return;
      }
      
      // è·å–å°ºå¯¸å‚æ•°
      const sizeType = document.getElementById('pageSize').value
      if (sizeType !== 'custom') {
        operations.resize = pageSizeMap[sizeType]
      } else {
        const widthInput = document.getElementById('customWidth');
        const heightInput = document.getElementById('customHeight');
        const customWidthErrorEl = document.getElementById('customWidthError');
        const customHeightErrorEl = document.getElementById('customHeightError');

        let validationPassed = true;
        let width = NaN;
        let height = NaN;

        if (widthInput) {
            width = parseFloat(widthInput.value);
        } else {
            console.error("PDF Resize Error: customWidth input element not found in DOM.");
            validationPassed = false; // Critical element missing
        }

        if (heightInput) {
            height = parseFloat(heightInput.value);
        } else {
            console.error("PDF Resize Error: customHeight input element not found in DOM.");
            validationPassed = false; // Critical element missing
        }
        
        // Proceed with validation only if critical elements were found for parsing
        if (validationPassed) {
            console.log(`Initial validation for width: ${width}, height: ${height}`);
            if (isNaN(width) || width <= 0) {
                console.log(`Width validation failed. Value: ${width}`);
                if (widthInput) {
                    console.log(`Attempting to style widthInput (ID: ${widthInput.id}). Current background: ${widthInput.style.backgroundColor}, Classes: ${widthInput.className}`);
                    heightInput.classList.add('input-error');
                    widthInput.classList.add('input-error');
                    console.log(`After styling widthInput. New background: ${widthInput.style.backgroundColor}, New classes: ${widthInput.className}`);
                    widthInput.focus();
                }
                const widthErrorMessage = 'å®½åº¦å¿…é¡»æ˜¯æœ‰æ•ˆçš„æ­£æ•°ã€‚';
                showToast(widthErrorMessage, 'error');
                if (customWidthErrorEl) {
                    console.log(`Attempting to show customWidthErrorEl (ID: ${customWidthErrorEl.id}). Current display: ${customWidthErrorEl.style.display}`);
                    customWidthErrorEl.textContent = widthErrorMessage;
                    customWidthErrorEl.style.display = 'block';
                    console.log(`After showing customWidthErrorEl. New display: ${customWidthErrorEl.style.display}, Text: ${customWidthErrorEl.textContent}`);
                } else {
                    console.error("PDF Resize Error: customWidthError element not found for displaying message.");
                }
                validationPassed = false;
                console.log(`Set validationPassed to false due to invalid width.`);
            }

            if (isNaN(height) || height <= 0) {
                console.log(`Height validation failed. Value: ${height}`);
                if (heightInput) {
                    console.log(`Attempting to style heightInput (ID: ${heightInput.id}). Current background: ${heightInput.style.backgroundColor}, Classes: ${heightInput.className}`);
                    widthInput.classList.add('input-error'); // Diagnostic style change
                    heightInput.classList.add('input-error');
                    console.log(`After styling heightInput. New background: ${heightInput.style.backgroundColor}, New classes: ${heightInput.className}`);
                    if (validationPassed && widthInput) {
                        heightInput.focus();
                    } else if (!widthInput && heightInput) {
                        heightInput.focus();
                    } else if (heightInput && !widthInput) { // If width was invalid but widthInput itself was missing
                        heightInput.focus();
                    } else if (validationPassed && !widthInput) { // If width was considered valid (e.g. not NaN) but widthInput was missing
                         heightInput.focus(); // Focus height if it's the first actual input field with an error
                    } else if (!validationPassed && heightInput) { // If width validation failed, and now height is also failing
                        // Let width keep focus if it was set, otherwise focus height if widthInput was missing
                        if(document.activeElement !== widthInput) heightInput.focus();
                    }


                }
                const heightErrorMessage = 'é«˜åº¦å¿…é¡»æ˜¯æœ‰æ•ˆçš„æ­£æ•°ã€‚';
                showToast(heightErrorMessage, 'error');
                if (customHeightErrorEl) {
                    console.log(`Attempting to show customHeightErrorEl (ID: ${customHeightErrorEl.id}). Current display: ${customHeightErrorEl.style.display}`);
                    customHeightErrorEl.textContent = heightErrorMessage;
                    customHeightErrorEl.style.display = 'block';
                    console.log(`After showing customHeightErrorEl. New display: ${customHeightErrorEl.style.display}, Text: ${customHeightErrorEl.textContent}`);
                } else {
                    console.error("PDF Resize Error: customHeightError element not found for displaying message.");
                }
                validationPassed = false;
                console.log(`Set validationPassed to false due to invalid height.`);
            }
        }

        console.log(`Final validationPassed state before return check: ${validationPassed}`);
        if (!validationPassed) {
          console.log("Validation failed (or critical elements missing), returning early from processBtn.");
          // Ensure button is reset if validation fails here
          if (processButton) {
              processButton.disabled = false;
              processButton.textContent = originalButtonText;
              processButton.classList.remove('processing');
          }
          if (timerInterval) clearInterval(timerInterval); // Clear timer if it started before this point
          return; // Stop if elements are missing or validation fails
        }
        console.log("Validation passed, proceeding to operations.resize.");

        // If we reach here, all elements were found and validation passed
        operations.resize = {
          width: width * 2.835, // width and height are guaranteed to be valid numbers here
          height: height * 2.835
        }
      }
      // --- Show Processing State ---
      let startTime = 0;
      // timerInterval is already declared in the outer scope (line 523)
      // processButton and originalButtonText are defined at the start of the event listener
      if (processButton) {
        processButton.disabled = true;
        startTime = Date.now();
        let secondsElapsed = 0;
        processButton.textContent = `æ­£åœ¨å¤„ç†ä¸­... (${secondsElapsed}ç§’)`;
        processButton.classList.add('processing'); // Add processing class
        timerInterval = setInterval(() => {
          secondsElapsed++;
          processButton.textContent = `æ­£åœ¨å¤„ç†ä¸­... (${secondsElapsed}ç§’)`;
        }, 1000);
      }
      // Optional: Show a processing message in resultDiv
      // const resultDivForProcessing = document.getElementById('result');
      // if (resultDivForProcessing) {
      //   resultDivForProcessing.innerHTML = '<p>æ­£åœ¨å¤„ç†ï¼Œè¯·ç¨å€™...</p>';
      //   resultDivForProcessing.className = 'info'; // Needs a .info style in CSS
      //   resultDivForProcessing.style.display = 'block';
      // }
      // --- End Show Processing State ---

      const finalOutputNameWithPdf = outputName.toLowerCase().endsWith('.pdf') ? outputName : outputName + '.pdf';
      console.log('[PDF Resize] Before calling window.electronAPI.processPDF. Params:', { filePath: selectedFilePath, operations, outputName: finalOutputNameWithPdf }); // DEBUG LOG
      const apiResult = await window.electronAPI.processPDF({ // Renamed to apiResult
        filePath: selectedFilePath,
        operations,
        outputName: finalOutputNameWithPdf // Pass name with .pdf
      });
      console.log('[PDF Resize] After calling window.electronAPI.processPDF. Result:', apiResult); // DEBUG LOG

      const endTime = Date.now();
      const totalTimeSeconds = ((endTime - startTime) / 1000).toFixed(2);

      const resultDiv = document.getElementById('result'); // Ensure it's defined before use
      if (apiResult && apiResult.success && apiResult.path) {
        showToast('å¤„ç†æˆåŠŸï¼', 'success');
        if (resultDiv) {
            resultDiv.style.display = 'block';
            let resultHtml = `<p>ä¿å­˜è·¯å¾„ï¼š${apiResult.path}</p>`;
            if (apiResult.outputFileSize !== null && apiResult.outputFileSize !== undefined) {
              resultHtml += `<p>æ–‡ä»¶å¤§å°ï¼š${formatBytes(apiResult.outputFileSize)}`;
              if (apiResult.outputPageCount !== null && apiResult.outputPageCount !== undefined) {
                resultHtml += `ï¼Œé¡µæ•°ï¼š${apiResult.outputPageCount}`;
              }
              resultHtml += `</p>`;
            } else if (apiResult.outputPageCount !== null && apiResult.outputPageCount !== undefined) {
              resultHtml += `<p>é¡µæ•°ï¼š${apiResult.outputPageCount}</p>`;
            }
            if(apiResult.metadataError){
                resultHtml += `<p style="color: orange;">è¾“å‡ºæ–‡ä»¶å…ƒæ•°æ®è­¦å‘Š: ${apiResult.metadataError}</p>`;
            }
            resultHtml += `<p>æ€»è€—æ—¶ï¼š${totalTimeSeconds}ç§’</p>`;
            resultDiv.innerHTML = resultHtml;
            resultDiv.className = 'success';
        }
        currentGeneratedPdfResizePath = apiResult.path;
        if (pdfResizePostProcessActionsDiv) {
            pdfResizePostProcessActionsDiv.style.display = 'block';
        }
      } else {
        handleAndShowApiError(apiResult, 'PDFå°ºå¯¸è°ƒæ•´', undefined, resultDiv, pdfResizePostProcessActionsDiv);
        if (resultDiv) { // Also show total time on error
            resultDiv.innerHTML += `<p>æ€»è€—æ—¶ï¼š${totalTimeSeconds}ç§’</p>`;
            if (!resultDiv.classList.contains('error')) { // Ensure error class if not already set
                resultDiv.className = 'error';
                resultDiv.style.display = 'block';
            }
        }
      }
    } catch (error) {
      console.error('[PDF Resize] Error in processBtn click handler:', error);
      const endTime = Date.now();
      const totalTimeSeconds = ((endTime - startTime) / 1000).toFixed(2);
      const errorResultDiv = document.getElementById('result');
      handleAndShowClientError(error, 'PDFå°ºå¯¸è°ƒæ•´', undefined, errorResultDiv, pdfResizePostProcessActionsDiv);
      if (errorResultDiv) { // Also show total time on client error
        errorResultDiv.innerHTML += `<p>æ€»è€—æ—¶ï¼š${totalTimeSeconds}ç§’</p>`;
      }
    } finally {
      // --- Reset Processing State ---
      if (timerInterval) clearInterval(timerInterval);
      // processButton and originalButtonText are defined at the start of the event listener
      if (processButton) {
          processButton.disabled = false;
          processButton.textContent = originalButtonText;
          processButton.classList.remove('processing'); // Remove processing class
      }
      // If resultDiv was used for a "processing..." message and not overwritten by success/failure,
      // it might need clearing here. However, current logic for success/failure does update resultDiv or hides it.
    }
    })

    // PDF Resize View - Clear Form Button
    const clearPdfResizeFormBtn = document.getElementById('clearPdfResizeFormBtn');
    if (clearPdfResizeFormBtn) {
      clearPdfResizeFormBtn.addEventListener('click', async () => {
        // Clear file selection
        selectedFilePath = '';
        updateFileSelectionUI(selectedFilePath, 'selectedFile', null, null); // Pass nulls for metadata
        appSettings.pdfResizeSelectedPath = '';
        const openFileButton = document.getElementById('openFile');
        const selectedFileErrorEl = document.getElementById('selectedFileError');
        if (openFileButton) openFileButton.classList.remove('input-error');
        if (selectedFileErrorEl) {
          selectedFileErrorEl.textContent = '';
          selectedFileErrorEl.style.display = 'none';
        }

        // Clear output name
        const pdfResizeOutputNameInput = document.getElementById('pdfResizeOutputName');
        if (pdfResizeOutputNameInput) pdfResizeOutputNameInput.value = '';
        appSettings.pdfResizeOutputName = '';

        // Reset page size
        const pageSizeSelect = document.getElementById('pageSize');
        if (pageSizeSelect) pageSizeSelect.value = 'Shein'; // Default to Shein
        appSettings.pageSize = 'Shein';
        const customSizeEl = document.getElementById('customSize');
        if (customSizeEl) customSizeEl.style.display = 'none';
        
        // Clear custom dimensions and their errors
        const customWidthInput = document.getElementById('customWidth');
        const customHeightInput = document.getElementById('customHeight');
        const customWidthErrorEl = document.getElementById('customWidthError');
        const customHeightErrorEl = document.getElementById('customHeightError');
        if (customWidthInput) {
          customWidthInput.value = '';
          customWidthInput.classList.remove('input-error');
        }
        if (customWidthErrorEl) {
          customWidthErrorEl.textContent = '';
          customWidthErrorEl.style.display = 'none';
        }
        appSettings.customWidth = '';

        if (customHeightInput) {
          customHeightInput.value = '';
          customHeightInput.classList.remove('input-error');
        }
        if (customHeightErrorEl) {
          customHeightErrorEl.textContent = '';
          customHeightErrorEl.style.display = 'none';
        }
        appSettings.customHeight = '';

        // Clear result and post-process actions
        const resultDiv = document.getElementById('result');
        if (resultDiv) {
          resultDiv.innerHTML = '';
          resultDiv.className = '';
          resultDiv.style.display = 'none';
        }
        if (pdfResizePostProcessActionsDiv) {
          pdfResizePostProcessActionsDiv.style.display = 'none';
        }
        currentGeneratedPdfResizePath = '';

        await window.electronAPI.saveSettings(appSettings);
        showToast('PDF å°ºå¯¸è°ƒæ•´è¡¨å•å·²æ¸…ç©º', 'info');
      });
    }

    // Event listeners for PDF Resize Post-Process Actions
    if (pdfResizeOpenGeneratedFileBtn) {
        pdfResizeOpenGeneratedFileBtn.addEventListener('click', async () => {
            if (currentGeneratedPdfResizePath) {
                try {
                    await window.electronAPI.openPath(currentGeneratedPdfResizePath);
                } catch (err) {
                    console.error("Error opening file (PDF Resize):", err);
                    const openFileErrorMsg = `æ— æ³•æ‰“å¼€ç”Ÿæˆçš„ PDF æ–‡ä»¶ã€‚è¯·æ£€æŸ¥æ–‡ä»¶æ˜¯å¦å­˜åœ¨æˆ–æ˜¯å¦æœ‰æƒé™è®¿é—®ã€‚ (é”™è¯¯: ${err.message})`;
                    showToast(openFileErrorMsg, 'error');
                }
            }
        });
    }

    if (pdfResizeShowGeneratedFileInFolderBtn) {
        pdfResizeShowGeneratedFileInFolderBtn.addEventListener('click', async () => {
            if (currentGeneratedPdfResizePath) {
                try {
                    await window.electronAPI.showItemInFolder(currentGeneratedPdfResizePath);
                } catch (err) {
                    console.error("Error showing item in folder (PDF Resize):", err);
                    const showInFolderErrorMsg = `æ— æ³•åœ¨æ–‡ä»¶å¤¹ä¸­æ˜¾ç¤ºè¯¥æ–‡ä»¶ã€‚è¯·æ£€æŸ¥è·¯å¾„æ˜¯å¦æœ‰æ•ˆã€‚ (é”™è¯¯: ${err.message})`;
                    showToast(showInFolderErrorMsg, 'error');
                }
            }
        });
    }

    if (pdfResizeCopyFileBtn) {
        pdfResizeCopyFileBtn.addEventListener('click', async () => {
            if (currentGeneratedPdfResizePath) {
                try {
                    // Assuming window.electronAPI.copyFileToClipboard will be implemented
                    // and will return an object like { success: true } or { success: false, error: 'message' }
                    const copyResult = await window.electronAPI.copyFileToClipboard(currentGeneratedPdfResizePath);
                    
                    if (copyResult && copyResult.success) {
                        if (copyResult.action === 'path_copied_unexpected_fallback') {
                            showToast(copyResult.message || 'æœªèƒ½å¤åˆ¶æ–‡ä»¶æœ¬èº«ï¼Œå·²æ”¹ä¸ºå¤åˆ¶æ–‡ä»¶è·¯å¾„è‡³å‰ªè´´æ¿ã€‚', 'warning', 5000);
                        } else {
                            showToast('æ–‡ä»¶å·²å¤åˆ¶åˆ°å‰ªè´´æ¿ï¼', 'success');
                        }
                        console.log('Copy action result (PDF Resize):', copyResult);
                    } else {
                        const defaultCopyError = 'è¯·æ£€æŸ¥æ–‡ä»¶æ˜¯å¦å­˜åœ¨æˆ–å‰ªè´´æ¿æƒé™ã€‚';
                        const errorMessage = `å¤åˆ¶æ–‡ä»¶å¤±è´¥: ${(copyResult && copyResult.error) ? copyResult.error : defaultCopyError}`;
                        console.error("Failed to copy file to clipboard (PDF Resize):", errorMessage);
                        showToast(errorMessage, 'error');
                    }
                } catch (err) {
                    console.error("Error during copy file operation (PDF Resize):", err);
                    const exceptionCopyErrorMsg = `å¤åˆ¶æ–‡ä»¶æ—¶å‘ç”Ÿæ„å¤–é”™è¯¯ã€‚ (é”™è¯¯: ${err.message})`;
                    showToast(exceptionCopyErrorMsg, 'error');
                }
            }
        });
    }

    // --- Shein Label Feature ---
    let selectedSheinPdf1Path = '';
    let selectedSheinPdf2Path = '';

    const sheinOpenFile1Btn = document.getElementById('sheinOpenFile1Btn');
    const sheinSelectedFile1Element = document.getElementById('sheinSelectedFile1');
    const sheinOpenFile2Btn = document.getElementById('sheinOpenFile2Btn');
    const sheinSelectedFile2Element = document.getElementById('sheinSelectedFile2');
    const generateSheinLabelBtn = document.getElementById('generateSheinLabelBtn');
    const sheinResultDiv = document.getElementById('sheinResult');
    const sheinOutputNameInput = document.getElementById('sheinOutputName');
    const sheinOutputPageSizeSelect = document.getElementById('sheinOutputPageSize'); // New select
    const sheinOutputCustomDimensionsDiv = document.getElementById('sheinOutputCustomDimensions'); // New div for custom inputs
    const sheinOutputWidthInput = document.getElementById('sheinOutputWidth'); // Existing input, now inside new div
    const sheinOutputHeightInput = document.getElementById('sheinOutputHeight'); // Existing input, now inside new div
    const sheinPostProcessActionsDiv = document.getElementById('sheinPostProcessActions');
    const openGeneratedFileBtn = document.getElementById('openGeneratedFileBtn'); // Note: These are generic IDs, ensure they are scoped correctly or made specific
    const showGeneratedFileInFolderBtn = document.getElementById('showGeneratedFileInFolderBtn'); // Same as above
    const sheinCopyFileBtn = document.getElementById('sheinCopyFileBtn'); // New button for Shein copy
    let currentGeneratedSheinLabelPath = ''; // To store the path for the buttons

    // Logic for Shein output page size selection
    if (sheinOutputPageSizeSelect) {
      sheinOutputPageSizeSelect.addEventListener('change', async function() { // Added async
        if (this.value === 'custom') {
          sheinOutputCustomDimensionsDiv.style.display = 'flex';
        } else {
          sheinOutputCustomDimensionsDiv.style.display = 'none';
          const selectedSizeMM = pageSizeMapMM[this.value];
          if (selectedSizeMM) {
            sheinOutputWidthInput.value = selectedSizeMM.width;
            sheinOutputHeightInput.value = selectedSizeMM.height;
          }
        }
        appSettings.sheinOutputPageSize = this.value;
        await window.electronAPI.saveSettings(appSettings);
      });
      // Trigger change on load to set initial state based on default "Shein" selection
      // This will hide custom inputs and ensure width/height inputs are 70/60
      // (though HTML value attributes already set them, this ensures consistency if default changes)
      // This logic will be handled by the general form loading logic later
    }

    // Old default dimension setting for Shein Label (lines 443-448) is now removed
    // as it's handled by the select logic and HTML value attributes.

    // Add event listeners to custom dimension inputs for Shein Label to clear errors on valid input
    const sheinOutputWidthErrorEl = document.getElementById('sheinOutputWidthError'); // Already got this for validation
    const sheinOutputHeightErrorEl = document.getElementById('sheinOutputHeightError'); // Already got this for validation

    if (sheinOutputWidthInput && sheinOutputWidthErrorEl) {
      sheinOutputWidthInput.addEventListener('input', () => {
        const widthVal = parseFloat(sheinOutputWidthInput.value);
        if (!isNaN(widthVal) && widthVal > 0) {
          sheinOutputWidthInput.classList.remove('input-error');
          sheinOutputWidthErrorEl.textContent = '';
          sheinOutputWidthErrorEl.style.display = 'none';
        }
      });
    }

    if (sheinOutputHeightInput && sheinOutputHeightErrorEl) {
      sheinOutputHeightInput.addEventListener('input', () => {
        const heightVal = parseFloat(sheinOutputHeightInput.value);
        if (!isNaN(heightVal) && heightVal > 0) {
          sheinOutputHeightInput.classList.remove('input-error');
          sheinOutputHeightErrorEl.textContent = '';
          sheinOutputHeightErrorEl.style.display = 'none';
        }
      });
    }

    // Add input event listener for sheinOutputName to clear error on valid input
    const sheinOutputNameInputForLiveValidation = document.getElementById('sheinOutputName');
    if (sheinOutputNameInputForLiveValidation) {
      sheinOutputNameInputForLiveValidation.addEventListener('input', function() {
        let tempOutputName = this.value.trim();
        // Similar to pdfResizeOutputName, handle potential .pdf extension for validation
        // isValidFilename should handle names with or without extensions correctly.
        const validation = isValidFilename(tempOutputName);
        if (validation.valid) {
          this.classList.remove('input-error');
        }
        // Only for clearing error, not adding it.
      });
    }

    // Apply file-selected-badge styling if needed (assuming styles.css has this class)
    // Ensure initial placeholder text
    if (sheinSelectedFile1Element) sheinSelectedFile1Element.textContent = 'æœªé€‰æ‹©æ–‡ä»¶';
    if (sheinSelectedFile2Element) sheinSelectedFile2Element.textContent = 'æœªé€‰æ‹©æ–‡ä»¶';


    if (sheinOpenFile1Btn) {
      sheinOpenFile1Btn.addEventListener('click', async () => {
        const newPath = await window.electronAPI.openFile();
        const sheinSelectedFile1ErrorEl = document.getElementById('sheinSelectedFile1Error');
        const sheinOpenFile1Button = document.getElementById('sheinOpenFile1Btn');
        
        // Always clear previous specific warning for EC Rep page count
        if (sheinSelectedFile1ErrorEl) {
            clearInlineFileError('sheinSelectedFile1Error');
        }

        if (!newPath) {
          showToast('æ“ä½œå·²å–æ¶ˆã€‚', 'info');
          //updateFileSelectionUI(selectedSheinPdf1Path, 'sheinSelectedFile1'); // Update with current (possibly old or empty)
        } else {
          selectedSheinPdf1Path = newPath;
          appSettings.sheinEcRepPdfPath = selectedSheinPdf1Path;
          // Immediately update UI to show filename and loading state
          updateFileSelectionUI(selectedSheinPdf1Path, 'sheinSelectedFile1', null, null, true);

          try {
            const metadata = await window.electronAPI.getPdfMetadata(selectedSheinPdf1Path);
            // Now update with full metadata
            if (metadata.success) {
              updateFileSelectionUI(selectedSheinPdf1Path, 'sheinSelectedFile1', metadata.pageCount, metadata.size, false);
              if (sheinOpenFile1Button) sheinOpenFile1Button.classList.remove('input-error');
              // No need to clear general error here, as it's for file selection, not page count.
              // The specific page count warning is handled below.

              if (metadata.pageCount !== null && metadata.pageCount !== 1) {
                const warningMsg = `è­¦å‘Šï¼šæ¬§ä»£æ–‡ä»¶é€šå¸¸ä¸º1é¡µã€‚å½“å‰é¡µæ•°ï¼š${metadata.pageCount}`;
                showToast('è¯·æ£€æŸ¥ï¼Œæ¬§ä»£PDFæ–‡ä»¶é€šå¸¸ä¸º1é¡µPDF', 'warning', 6000);
                if (sheinSelectedFile1ErrorEl) {
                  sheinSelectedFile1ErrorEl.textContent = warningMsg;
                  sheinSelectedFile1ErrorEl.style.display = 'block';
                  sheinSelectedFile1ErrorEl.classList.add('warning-text'); // Add class for styling
                }
              }
            } else {
              showToast(`æ— æ³•è¯»å–æ¬§ä»£æ–‡ä»¶å…ƒæ•°æ®: ${metadata.error || 'æœªçŸ¥é”™è¯¯'}`, 'error');
              updateFileSelectionUI(selectedSheinPdf1Path, 'sheinSelectedFile1', null, null, false); // Show filename at least, remove loading
            }
          } catch (err) {
            showToast(`è·å–æ¬§ä»£æ–‡ä»¶å…ƒæ•°æ®æ—¶å‡ºé”™: ${err.message}`, 'error');
            updateFileSelectionUI(selectedSheinPdf1Path, 'sheinSelectedFile1', null, null, false); // Show filename at least, remove loading
          }
          const saveResult = await window.electronAPI.saveSettings(appSettings);
          if (!saveResult || !saveResult.success) {
            console.error('Failed to save settings after Shein File 1 selection:', saveResult ? saveResult.error : 'Unknown error');
            showToast('è­¦å‘Šï¼šæ— æ³•ä¿å­˜æ–‡ä»¶é€‰æ‹©è®¾ç½®ã€‚', 'warning');
          }
        }
      });
    }

    if (sheinOpenFile2Btn) {
      sheinOpenFile2Btn.addEventListener('click', async () => {
        const newPath = await window.electronAPI.openFile();
        const sheinOpenFile2Button = document.getElementById('sheinOpenFile2Btn');
        const sheinSelectedFile2ErrorEl = document.getElementById('sheinSelectedFile2Error');

        if (!newPath) {
          showToast('æ“ä½œå·²å–æ¶ˆã€‚', 'info');
          //updateFileSelectionUI(selectedSheinPdf2Path, 'sheinSelectedFile2');
        } else {
          selectedSheinPdf2Path = newPath;
          appSettings.sheinBarcodePdfPath = selectedSheinPdf2Path;
          // Immediately update UI to show filename and loading state
          updateFileSelectionUI(selectedSheinPdf2Path, 'sheinSelectedFile2', null, null, true);

          try {
            const metadata = await window.electronAPI.getPdfMetadata(selectedSheinPdf2Path);
            // Now update with full metadata
            if (metadata.success) {
              updateFileSelectionUI(selectedSheinPdf2Path, 'sheinSelectedFile2', metadata.pageCount, metadata.size, false);
              if (sheinOpenFile2Button) sheinOpenFile2Button.classList.remove('input-error');
              if (sheinSelectedFile2ErrorEl) {
                  clearInlineFileError('sheinSelectedFile2Error'); // Clear general file selection error
              }
            } else {
              showToast(`æ— æ³•è¯»å–æ¡ç æ–‡ä»¶å…ƒæ•°æ®: ${metadata.error || 'æœªçŸ¥é”™è¯¯'}`, 'error');
              updateFileSelectionUI(selectedSheinPdf2Path, 'sheinSelectedFile2', null, null, false); // Show filename at least, remove loading
            }
          } catch (err) {
            showToast(`è·å–æ¡ç æ–‡ä»¶å…ƒæ•°æ®æ—¶å‡ºé”™: ${err.message}`, 'error');
            updateFileSelectionUI(selectedSheinPdf2Path, 'sheinSelectedFile2', null, null, false); // Show filename at least, remove loading
          }
  
          // Auto-fill output name for Shein Label (based on barcode file)
          const sheinOutputNameInput = document.getElementById('sheinOutputName');
          if (sheinOutputNameInput) {
            const baseNameNoExt = getFilenameWithoutExtension(selectedSheinPdf2Path);
            const newOutputName = `${baseNameNoExt}_Sheinæ ‡ç­¾_${getCurrentHHMMSS()}`; // No .pdf here
            sheinOutputNameInput.value = newOutputName;
            // Trigger input event for live validation and settings saving
            const inputEvent = new Event('input', { bubbles: true });
            sheinOutputNameInput.dispatchEvent(inputEvent);
          }
          
          const saveResult = await window.electronAPI.saveSettings(appSettings); // Save other settings like selected path
          if (!saveResult || !saveResult.success) {
            console.error('Failed to save settings after Shein File 2 selection:', saveResult ? saveResult.error : 'Unknown error');
            showToast('è­¦å‘Šï¼šæ— æ³•ä¿å­˜æ–‡ä»¶é€‰æ‹©è®¾ç½®ã€‚', 'warning');
          }
        }
      });
    }

    if (generateSheinLabelBtn) {
      // Event listeners for open/show buttons, defined once
      openGeneratedFileBtn.addEventListener('click', async () => {
        if (currentGeneratedSheinLabelPath) {
          try {
            await window.electronAPI.openPath(currentGeneratedSheinLabelPath);
          } catch (err) {
            console.error("Error opening file (Shein Label):", err);
            const openFileErrorMsgShein = `æ— æ³•æ‰“å¼€ç”Ÿæˆçš„ Shein Label æ–‡ä»¶ã€‚è¯·æ£€æŸ¥æ–‡ä»¶æ˜¯å¦å­˜åœ¨æˆ–æ˜¯å¦æœ‰æƒé™è®¿é—®ã€‚ (é”™è¯¯: ${err.message})`;
            showToast(openFileErrorMsgShein, 'error');
          }
        }
      });

      showGeneratedFileInFolderBtn.addEventListener('click', async () => {
        if (currentGeneratedSheinLabelPath) {
          try {
            await window.electronAPI.showItemInFolder(currentGeneratedSheinLabelPath);
          } catch (err) {
            console.error("Error showing item in folder (Shein Label):", err);
            const showInFolderErrorMsgShein = `æ— æ³•åœ¨æ–‡ä»¶å¤¹ä¸­æ˜¾ç¤ºè¯¥ Shein Label æ–‡ä»¶ã€‚è¯·æ£€æŸ¥è·¯å¾„æ˜¯å¦æœ‰æ•ˆã€‚ (é”™è¯¯: ${err.message})`;
            showToast(showInFolderErrorMsgShein, 'error');
          }
        }
      });

      if (sheinCopyFileBtn) {
        sheinCopyFileBtn.addEventListener('click', async () => {
          if (currentGeneratedSheinLabelPath) {
            try {
              const copyResult = await window.electronAPI.copyFileToClipboard(currentGeneratedSheinLabelPath);

              if (copyResult && copyResult.success) {
                if (copyResult.action === 'path_copied_unexpected_fallback') {
                  showToast(copyResult.message || 'æœªèƒ½å¤åˆ¶æ–‡ä»¶æœ¬èº«ï¼Œå·²æ”¹ä¸ºå¤åˆ¶æ–‡ä»¶è·¯å¾„è‡³å‰ªè´´æ¿ã€‚', 'warning', 5000);
                } else {
                  showToast('æ–‡ä»¶å·²å¤åˆ¶åˆ°å‰ªè´´æ¿ï¼', 'success');
                }
                console.log('Copy action result (Shein Label):', copyResult);
              } else {
                const defaultCopyErrorShein = 'è¯·æ£€æŸ¥æ–‡ä»¶æ˜¯å¦å­˜åœ¨æˆ–å‰ªè´´æ¿æƒé™ã€‚';
                const errorMessage = `å¤åˆ¶æ–‡ä»¶å¤±è´¥: ${(copyResult && copyResult.error) ? copyResult.error : defaultCopyErrorShein}`;
                console.error("Failed to copy file to clipboard (Shein Label):", errorMessage);
                showToast(errorMessage, 'error');
              }
            } catch (err) {
              console.error("Error during copy file operation (Shein Label):", err);
              const exceptionCopyErrorMsgShein = `å¤åˆ¶ Shein Label æ–‡ä»¶æ—¶å‘ç”Ÿæ„å¤–é”™è¯¯ã€‚ (é”™è¯¯: ${err.message})`;
              showToast(exceptionCopyErrorMsgShein, 'error');
            }
          }
        });
      }

      generateSheinLabelBtn.addEventListener('click', async () => {
        const originalButtonText = generateSheinLabelBtn.textContent; // Store original button text
        let startTime = 0;
        let timerInterval;

        generateSheinLabelBtn.disabled = true;
        startTime = Date.now();
        let secondsElapsed = 0;
        generateSheinLabelBtn.textContent = `æ­£åœ¨å¤„ç†ä¸­... (${secondsElapsed}ç§’)`;
        // generateSheinLabelBtn.classList.add('processing'); // Will be added after validation

        sheinResultDiv.innerHTML = ''; // Clear previous results
        sheinResultDiv.className = '';
        sheinResultDiv.style.display = 'none'; // Hide when resetting
        sheinPostProcessActionsDiv.style.display = 'none'; // Hide actions at the start
        currentGeneratedSheinLabelPath = ''; // Reset path

        // Reset inline error messages for Shein file inputs
        const sheinOpenFile1ButtonForReset = document.getElementById('sheinOpenFile1Btn');
        const sheinSelectedFile1ErrorForReset = document.getElementById('sheinSelectedFile1Error');
        if (sheinOpenFile1ButtonForReset && sheinSelectedFile1ErrorForReset) {
            sheinOpenFile1ButtonForReset.classList.remove('input-error');
            sheinSelectedFile1ErrorForReset.textContent = '';
            sheinSelectedFile1ErrorForReset.style.display = 'none';
        }

        const sheinOpenFile2ButtonForReset = document.getElementById('sheinOpenFile2Btn');
        const sheinSelectedFile2ErrorForReset = document.getElementById('sheinSelectedFile2Error');
        if (sheinOpenFile2ButtonForReset && sheinSelectedFile2ErrorForReset) {
            sheinOpenFile2ButtonForReset.classList.remove('input-error');
            selectedSheinPdf2Path.textContent = '';
            sheinSelectedFile2ErrorForReset.style.display = 'none';
        }
        // Reset inline error messages for Shein custom dimensions
        const sheinOutputWidthErrorElForReset = document.getElementById('sheinOutputWidthError');
        const sheinOutputHeightErrorElForReset = document.getElementById('sheinOutputHeightError');
        if (sheinOutputWidthInput && sheinOutputWidthErrorElForReset) {
            sheinOutputWidthInput.classList.remove('input-error');
            sheinOutputWidthErrorElForReset.textContent = '';
            sheinOutputWidthErrorElForReset.style.display = 'none';
        }
        if (sheinOutputHeightInput && sheinOutputHeightErrorElForReset) {
            sheinOutputHeightInput.classList.remove('input-error');
            sheinOutputHeightErrorElForReset.textContent = '';
            sheinOutputHeightErrorElForReset.style.display = 'none';
        }

        let sheinValidationPassed = true;

        if (!selectedSheinPdf1Path) {
          const sheinOpenFile1Button = document.getElementById('sheinOpenFile1Btn');
          const sheinSelectedFile1ErrorEl = document.getElementById('sheinSelectedFile1Error');
          const errorMessage1 = 'è¯·é€‰æ‹©æ¬§ä»£æ–‡ä»¶ã€‚';
          showToast(errorMessage1, 'error');
          if (sheinOpenFile1Button) {
              sheinOpenFile1Button.classList.add('input-error');
          }
          if (sheinSelectedFile1ErrorEl) {
              sheinSelectedFile1ErrorEl.textContent = errorMessage1;
              sheinSelectedFile1ErrorEl.style.display = 'block';
          } else {
              console.error("Shein Label Error: sheinSelectedFile1Error element not found in DOM!");
              if (sheinResultDiv) {
                  sheinResultDiv.innerHTML = '<p>è¯·é€‰æ‹©æ¬§ä»£æ–‡ä»¶ (UI Error: msg element missing)</p>';
                  sheinResultDiv.className = 'error';
                  sheinResultDiv.style.display = 'block';
              }
          }
          sheinValidationPassed = false;
        }

        if (!selectedSheinPdf2Path) {
          const sheinOpenFile2Button = document.getElementById('sheinOpenFile2Btn');
          const sheinSelectedFile2ErrorEl = document.getElementById('sheinSelectedFile2Error');
          const errorMessage2 = 'è¯·é€‰æ‹©æ¡ç æ–‡ä»¶ã€‚';
          showToast(errorMessage2, 'error');
          if (sheinOpenFile2Button) {
              sheinOpenFile2Button.classList.add('input-error');
          }
          if (sheinSelectedFile2ErrorEl) {
              sheinSelectedFile2ErrorEl.textContent = errorMessage2;
              sheinSelectedFile2ErrorEl.style.display = 'block';
          } else {
              console.error("Shein Label Error: sheinSelectedFile2Error element not found in DOM!");
              if (sheinResultDiv) { // Fallback
                  sheinResultDiv.innerHTML = '<p>è¯·é€‰æ‹©æ¡ç æ–‡ä»¶ (UI Error: msg element missing)</p>';
                  sheinResultDiv.className = 'error';
                  sheinResultDiv.style.display = 'block';
              }
          }
          sheinValidationPassed = false;
        }
        
        const sheinPageSizeSelectedValue = sheinOutputPageSizeSelect.value;
        let outputWidth = parseFloat(sheinOutputWidthInput.value);
        let outputHeight = parseFloat(sheinOutputHeightInput.value);
        const sheinOutputWidthErrorEl = document.getElementById('sheinOutputWidthError');
        const sheinOutputHeightErrorEl = document.getElementById('sheinOutputHeightError');

        if (sheinPageSizeSelectedValue === 'custom') {
            if (isNaN(outputWidth) || outputWidth <= 0) {
                const sheinWidthErrorMessage = 'å®½åº¦å¿…é¡»æ˜¯æœ‰æ•ˆçš„æ­£æ•°ã€‚';
                showToast(sheinWidthErrorMessage, 'error');
                if (sheinOutputWidthInput) sheinOutputWidthInput.classList.add('input-error');
                if (sheinOutputWidthErrorEl) {
                    sheinOutputWidthErrorEl.textContent = sheinWidthErrorMessage;
                    sheinOutputWidthErrorEl.style.display = 'block';
                }
                if (sheinValidationPassed && sheinOutputWidthInput) sheinOutputWidthInput.focus();
                sheinValidationPassed = false;
            }
            if (isNaN(outputHeight) || outputHeight <= 0) {
                const sheinHeightErrorMessage = 'é«˜åº¦å¿…é¡»æ˜¯æœ‰æ•ˆçš„æ­£æ•°ã€‚';
                showToast(sheinHeightErrorMessage, 'error');
                if (sheinOutputHeightInput) sheinOutputHeightInput.classList.add('input-error');
                if (sheinOutputHeightErrorEl) {
                    sheinOutputHeightErrorEl.textContent = sheinHeightErrorMessage;
                    sheinOutputHeightErrorEl.style.display = 'block';
                }
                if (sheinValidationPassed && sheinOutputHeightInput) sheinOutputHeightInput.focus();
                else if (!sheinValidationPassed && sheinOutputWidthInput && document.activeElement !== sheinOutputWidthInput && sheinOutputHeightInput) {
                     sheinOutputHeightInput.focus();
                } else if (!sheinOutputWidthInput && sheinOutputHeightInput) {
                    sheinOutputHeightInput.focus();
                }
                sheinValidationPassed = false;
            }
        } else {
            const presetSize = pageSizeMapMM[sheinPageSizeSelectedValue];
            if (presetSize) {
                outputWidth = presetSize.width;
                outputHeight = presetSize.height;
            } else {
                console.error("Shein Label: Selected preset size not found in map. Using defaults.");
                outputWidth = 70;
                outputHeight = 60;
            }
        }

        if (!sheinValidationPassed) {
          generateSheinLabelBtn.disabled = false;
          generateSheinLabelBtn.textContent = originalButtonText;
          // generateSheinLabelBtn.classList.remove('processing'); // Not added yet
          if(timerInterval) clearInterval(timerInterval); // Clear interval if validation fails after it started (though unlikely here)
          return;
        }
        
        // If validation passed, now add processing class and start timer
        generateSheinLabelBtn.classList.add('processing');
        timerInterval = setInterval(() => {
          secondsElapsed++;
          generateSheinLabelBtn.textContent = `æ­£åœ¨å¤„ç†ä¸­... (${secondsElapsed}ç§’)`;
        }, 1000);

        // getCurrentHHMMSS is now a global helper function

        let outputName = sheinOutputNameInput.value.trim();
        // Auto-generation of outputName if empty is now handled by file selection,
        // but keep this as a fallback if user clears it and then clicks process.
        if (!outputName) {
          const base = selectedSheinPdf2Path ? getFilenameWithoutExtension(selectedSheinPdf2Path) : 'SheinLabel_file';
          outputName = `${base}_Sheinæ ‡ç­¾_${getCurrentHHMMSS()}`; // No .pdf here
          // sheinOutputNameInput.value = outputName; // Optionally update the input if it was empty
        }

        // Validate the name part without .pdf
        const sheinFilenameValidation = isValidFilename(outputName);
        if (!sheinFilenameValidation.valid) {
          showToast(sheinFilenameValidation.message, 'error');
          if (sheinOutputNameInput) {
            sheinOutputNameInput.classList.add('input-error');
            sheinOutputNameInput.focus();
          }
          // Restore button state if validation fails before processing starts
          // generateSheinLabelBtn, originalButtonText, timerInterval are defined in this scope
          generateSheinLabelBtn.disabled = false;
          generateSheinLabelBtn.textContent = originalButtonText;
          generateSheinLabelBtn.classList.remove('processing'); // Remove if added before validation
          if (timerInterval) clearInterval(timerInterval);
          return;
        }
        
        const params = {
          pdf1Path: selectedSheinPdf1Path,
          pdf2Path: selectedSheinPdf2Path,
          outputName: outputName.toLowerCase().endsWith('.pdf') ? outputName : outputName + '.pdf', // Add .pdf before sending to API
          outputWidthMM: outputWidth,
          outputHeightMM: outputHeight
        };

        try {
          const result = await window.electronAPI.generateSheinLabel(params);
          const endTime = Date.now();
          const totalTimeSeconds = ((endTime - startTime) / 1000).toFixed(2);

          if (result.success && result.path) {
            currentGeneratedSheinLabelPath = result.path;
            showToast('Shein Label ç”ŸæˆæˆåŠŸï¼', 'success');
            sheinResultDiv.style.display = 'block';
            let resultHtmlShein = `<p>ä¿å­˜è·¯å¾„ï¼š${result.path}</p>`;
            if (result.outputFileSize !== null && result.outputFileSize !== undefined) {
              resultHtmlShein += `<p>æ–‡ä»¶å¤§å°ï¼š${formatBytes(result.outputFileSize)}`;
              if (result.outputPageCount !== null && result.outputPageCount !== undefined) {
                resultHtmlShein += `ï¼Œé¡µæ•°ï¼š${result.outputPageCount}`;
              }
              resultHtmlShein += `</p>`;
            } else if (result.outputPageCount !== null && result.outputPageCount !== undefined) {
               resultHtmlShein += `<p>é¡µæ•°ï¼š${result.outputPageCount}</p>`;
            }
            if(result.metadataError){
                resultHtmlShein += `<p style="color: orange;">è¾“å‡ºæ–‡ä»¶å…ƒæ•°æ®è­¦å‘Š: ${result.metadataError}</p>`;
            }
            resultHtmlShein += `<p>æ€»è€—æ—¶ï¼š${totalTimeSeconds}ç§’</p>`;
            sheinResultDiv.innerHTML = resultHtmlShein;
            sheinResultDiv.className = 'success';
            sheinPostProcessActionsDiv.style.display = 'block';
          } else {
            handleAndShowApiError(result, 'Shein Label ç”Ÿæˆ', undefined, sheinResultDiv, sheinPostProcessActionsDiv);
            if (sheinResultDiv) {
                sheinResultDiv.innerHTML += `<p>æ€»è€—æ—¶ï¼š${totalTimeSeconds}ç§’</p>`;
                 if (!sheinResultDiv.classList.contains('error')) {
                    sheinResultDiv.className = 'error';
                    sheinResultDiv.style.display = 'block';
                }
            }
          }
        } catch (error) {
          console.error('Error calling generateSheinLabel:', error);
          const endTime = Date.now();
          const totalTimeSeconds = ((endTime - startTime) / 1000).toFixed(2);
          const errorSheinResultDiv = sheinResultDiv; // Use existing sheinResultDiv
          handleAndShowClientError(error, 'Shein Label ç”Ÿæˆ', undefined, errorSheinResultDiv, sheinPostProcessActionsDiv);
          if (errorSheinResultDiv) {
            errorSheinResultDiv.innerHTML += `<p>æ€»è€—æ—¶ï¼š${totalTimeSeconds}ç§’</p>`;
          }
        } finally {
          if (timerInterval) clearInterval(timerInterval);
          generateSheinLabelBtn.disabled = false;
          generateSheinLabelBtn.textContent = originalButtonText;
          generateSheinLabelBtn.classList.remove('processing');
        }
      });

    // Shein Label View - Clear Form Button
    const clearSheinLabelFormBtn = document.getElementById('clearSheinLabelFormBtn');
    if (clearSheinLabelFormBtn) {
      clearSheinLabelFormBtn.addEventListener('click', async () => {
        // Clear file selections
        selectedSheinPdf1Path = '';
        updateFileSelectionUI(selectedSheinPdf1Path, 'sheinSelectedFile1', null, null);
        appSettings.sheinEcRepPdfPath = '';
        const sheinOpenFile1Button = document.getElementById('sheinOpenFile1Btn');
        if (sheinOpenFile1Button) sheinOpenFile1Button.classList.remove('input-error');
        clearInlineFileError('sheinSelectedFile1Error'); // Clear specific EC rep warning too

        selectedSheinPdf2Path = '';
        updateFileSelectionUI(selectedSheinPdf2Path, 'sheinSelectedFile2', null, null);
        appSettings.sheinBarcodePdfPath = '';
        const sheinOpenFile2Button = document.getElementById('sheinOpenFile2Btn');
        if (sheinOpenFile2Button) sheinOpenFile2Button.classList.remove('input-error');
        clearInlineFileError('sheinSelectedFile2Error');

        // Clear output name
        if (sheinOutputNameInput) sheinOutputNameInput.value = '';
        appSettings.sheinOutputName = '';

        // Reset output page size and custom dimensions
        if (sheinOutputPageSizeSelect) sheinOutputPageSizeSelect.value = 'Shein'; // Default to Shein
        appSettings.sheinOutputPageSize = 'Shein';
        if (sheinOutputCustomDimensionsDiv) sheinOutputCustomDimensionsDiv.style.display = 'none';
        
        if (sheinOutputWidthInput) {
          sheinOutputWidthInput.value = '70'; // Default Shein width
          sheinOutputWidthInput.classList.remove('input-error');
        }
        appSettings.sheinOutputWidth = '70';
        const sheinOutputWidthErrorEl = document.getElementById('sheinOutputWidthError');
        if (sheinOutputWidthErrorEl) {
          sheinOutputWidthErrorEl.textContent = '';
          sheinOutputWidthErrorEl.style.display = 'none';
        }

        if (sheinOutputHeightInput) {
          sheinOutputHeightInput.value = '60'; // Default Shein height
          sheinOutputHeightInput.classList.remove('input-error');
        }
        appSettings.sheinOutputHeight = '60';
        const sheinOutputHeightErrorEl = document.getElementById('sheinOutputHeightError');
        if (sheinOutputHeightErrorEl) {
          sheinOutputHeightErrorEl.textContent = '';
          sheinOutputHeightErrorEl.style.display = 'none';
        }
        
        // Trigger change on select to update UI correctly (e.g., hide custom dimensions)
        if (sheinOutputPageSizeSelect) {
            const event = new Event('change', { bubbles: true });
            sheinOutputPageSizeSelect.dispatchEvent(event);
        }


        // Clear result and post-process actions
        if (sheinResultDiv) {
          sheinResultDiv.innerHTML = '';
          sheinResultDiv.className = '';
          sheinResultDiv.style.display = 'none';
        }
        if (sheinPostProcessActionsDiv) {
          sheinPostProcessActionsDiv.style.display = 'none';
        }
        currentGeneratedSheinLabelPath = '';

        await window.electronAPI.saveSettings(appSettings);
        showToast('Shein Label ç”Ÿæˆè¡¨å•å·²æ¸…ç©º', 'info');
      });
    }
    }
    // --- End Shein Label Feature ---

    // --- Custom Select Dropdown Logic ---
    function initializeCustomSelect(originalSelectElement) {
      if (!originalSelectElement) return;

      const customSelectContainer = originalSelectElement.parentElement.querySelector('.custom-select-container');
      if (!customSelectContainer) return;

      const trigger = customSelectContainer.querySelector('.custom-select-trigger');
      const optionsContainer = customSelectContainer.querySelector('.custom-select-options');
      const triggerSpan = trigger.querySelector('span');

      // Clear existing custom options
      optionsContainer.innerHTML = '';

      // Populate custom options from original select
      Array.from(originalSelectElement.options).forEach(option => {
        const customOption = document.createElement('div');
        customOption.classList.add('custom-select-option');
        customOption.textContent = option.textContent;
        customOption.dataset.value = option.value;
        if (option.selected) {
          triggerSpan.textContent = option.textContent;
          customOption.classList.add('selected');
        }
        
        customOption.addEventListener('click', () => {
          // Update trigger text
          triggerSpan.textContent = customOption.textContent;
          
          // Update original select value
          originalSelectElement.value = customOption.dataset.value;
          
          // Remove 'selected' from previously selected custom option
          const currentlySelected = optionsContainer.querySelector('.custom-select-option.selected');
          if (currentlySelected) {
            currentlySelected.classList.remove('selected');
          }
          // Add 'selected' to current custom option
          customOption.classList.add('selected');
          
          // Close options
          optionsContainer.style.display = 'none';
          customSelectContainer.classList.remove('open');
          
          // Dispatch change event on original select
          const changeEvent = new Event('change', { bubbles: true });
          originalSelectElement.dispatchEvent(changeEvent);
        });
        optionsContainer.appendChild(customOption);
      });

      trigger.addEventListener('click', (e) => {
        e.stopPropagation(); // Prevent click from bubbling to document listener immediately
        const isOpen = optionsContainer.style.display === 'block';
        closeAllCustomSelects(customSelectContainer); // Close others before opening/closing current
        if (!isOpen) {
          optionsContainer.style.display = 'block';
          customSelectContainer.classList.add('open');
        } else {
          // Already handled by closeAllCustomSelects if it was this one
        }
      });
    }

    function closeAllCustomSelects(exceptThisOne = null) {
      document.querySelectorAll('.custom-select-container').forEach(container => {
        if (container !== exceptThisOne) {
          container.querySelector('.custom-select-options').style.display = 'none';
          container.classList.remove('open');
        }
      });
    }

    document.addEventListener('click', () => {
      closeAllCustomSelects();
    });

    // --- Load All Settings and Initialize UI ---
    async function loadAndApplySettings() {
      appSettings = await window.electronAPI.getSettings();
      if (!appSettings || Object.keys(appSettings).length === 0) {
        appSettings = { // Default structure if no settings file or empty
          activeView: defaultViewId,
          theme: 'light',
          pdfResizeSelectedPath: '',
          sheinEcRepPdfPath: '',
          sheinBarcodePdfPath: '',
          pdfResizeOutputName: '',
          pageSize: 'Shein',
          customWidth: '',
          customHeight: '',
          sheinOutputName: '',
          sheinOutputPageSize: 'Shein',
          sheinOutputWidth: '70',
          sheinOutputHeight: '60'
        };
      }

      // Activate saved view or default
      if (!activateView(appSettings.activeView || defaultViewId)) {
         activateView(defaultViewId); // Fallback if saved view is invalid
      }
      
      // Set theme (without re-saving immediately)
      await setTheme(appSettings.theme || 'light', false);

      // Load selected file paths and their metadata
      selectedFilePath = appSettings.pdfResizeSelectedPath || '';
      if (selectedFilePath) {
        // On load, show loading state first, then fetch metadata
        updateFileSelectionUI(selectedFilePath, 'selectedFile', null, null, true);
        try {
          const metadata = await window.electronAPI.getPdfMetadata(selectedFilePath);
          updateFileSelectionUI(selectedFilePath, 'selectedFile', metadata.pageCount, metadata.size, false);
        } catch (e) { updateFileSelectionUI(selectedFilePath, 'selectedFile', null, null, false); /* Show filename at least, remove loading */ }
      } else {
        updateFileSelectionUI(null, 'selectedFile');
      }

      selectedSheinPdf1Path = appSettings.sheinEcRepPdfPath || '';
      if (selectedSheinPdf1Path) {
        updateFileSelectionUI(selectedSheinPdf1Path, 'sheinSelectedFile1', null, null, true);
        try {
          const metadata = await window.electronAPI.getPdfMetadata(selectedSheinPdf1Path);
          updateFileSelectionUI(selectedSheinPdf1Path, 'sheinSelectedFile1', metadata.pageCount, metadata.size, false);
           // Also re-check EC Rep page count warning on load
          const sheinSelectedFile1ErrorEl = document.getElementById('sheinSelectedFile1Error');
          if (sheinSelectedFile1ErrorEl) clearInlineFileError('sheinSelectedFile1Error'); // Clear previous before check
          if (metadata.success && metadata.pageCount !== null && metadata.pageCount !== 1) {
            const warningMsg = `è­¦å‘Šï¼šæ¬§ä»£æ–‡ä»¶é€šå¸¸ä¸º1é¡µã€‚å½“å‰é¡µæ•°ï¼š${metadata.pageCount}`;
            // No toast on load, just inline warning
            if (sheinSelectedFile1ErrorEl) {
              sheinSelectedFile1ErrorEl.textContent = warningMsg;
              sheinSelectedFile1ErrorEl.style.display = 'block';
              sheinSelectedFile1ErrorEl.classList.add('warning-text');
            }
          }
        } catch (e) { updateFileSelectionUI(selectedSheinPdf1Path, 'sheinSelectedFile1', null, null, false); }
      } else {
        updateFileSelectionUI(null, 'sheinSelectedFile1');
        clearInlineFileError('sheinSelectedFile1Error');
      }

      selectedSheinPdf2Path = appSettings.sheinBarcodePdfPath || '';
      if (selectedSheinPdf2Path) {
        updateFileSelectionUI(selectedSheinPdf2Path, 'sheinSelectedFile2', null, null, true);
        try {
          const metadata = await window.electronAPI.getPdfMetadata(selectedSheinPdf2Path);
          updateFileSelectionUI(selectedSheinPdf2Path, 'sheinSelectedFile2', metadata.pageCount, metadata.size, false);
        } catch (e) { updateFileSelectionUI(selectedSheinPdf2Path, 'sheinSelectedFile2', null, null, false); }
      } else {
        updateFileSelectionUI(null, 'sheinSelectedFile2');
      }
      
      // Load form elements
      const formElementsToPersist = [
        { id: 'pdfResizeOutputName', type: 'text' },
        { id: 'pageSize', type: 'select' },
        { id: 'customWidth', type: 'number' },
        { id: 'customHeight', type: 'number' },
        { id: 'sheinOutputName', type: 'text' },
        { id: 'sheinOutputPageSize', type: 'select' },
        { id: 'sheinOutputWidth', type: 'number' },
        { id: 'sheinOutputHeight', type: 'number' }
      ];

      formElementsToPersist.forEach(elementConfig => {
        const el = document.getElementById(elementConfig.id);
        if (el) {
          // Load saved value from appSettings
          const savedValue = appSettings[elementConfig.id];
          if (savedValue !== undefined && savedValue !== null && savedValue !== '') {
            el.value = savedValue;
          }

          // Special handling for select elements to trigger dependent UI updates
          if (elementConfig.type === 'select') {
            setTimeout(() => {
              const event = new Event('change', { bubbles: true });
              el.dispatchEvent(event);
            }, 0);
          }
          
          // Attach saver
          const eventType = (el.tagName === 'SELECT' || elementConfig.type === 'select') ? 'change' : 'input';
          el.addEventListener(eventType, async () => { // Already async, ensure it's correct
            appSettings[el.id] = el.value;
            await window.electronAPI.saveSettings(appSettings);
          });
        }
      });

      // Initialize custom selects after settings are loaded and original selects are populated
      const pageSizeSelectEl = document.getElementById('pageSize');
      const sheinOutputPageSizeSelectEl = document.getElementById('sheinOutputPageSize');
      
      if (pageSizeSelectEl) initializeCustomSelect(pageSizeSelectEl);
      if (sheinOutputPageSizeSelectEl) initializeCustomSelect(sheinOutputPageSizeSelectEl);

      // Ensure custom select trigger text is updated if settings load changes the original select's value
      // This is important if the default selected option in HTML differs from the loaded setting.
      if (pageSizeSelectEl && appSettings.pageSize) {
          const customTriggerSpan = pageSizeSelectEl.parentElement.querySelector('.custom-select-trigger span');
          const selectedOption = Array.from(pageSizeSelectEl.options).find(opt => opt.value === appSettings.pageSize);
          if (customTriggerSpan && selectedOption) {
              customTriggerSpan.textContent = selectedOption.textContent;
              // Also mark the correct custom option as selected
              const customOptionsContainer = pageSizeSelectEl.parentElement.querySelector('.custom-select-options');
              const currentCustomSelected = customOptionsContainer.querySelector('.custom-select-option.selected');
              if(currentCustomSelected) currentCustomSelected.classList.remove('selected');
              const newCustomSelected = customOptionsContainer.querySelector(`.custom-select-option[data-value="${appSettings.pageSize}"]`);
              if(newCustomSelected) newCustomSelected.classList.add('selected');
          }
      }
      if (sheinOutputPageSizeSelectEl && appSettings.sheinOutputPageSize) {
          const customTriggerSpan = sheinOutputPageSizeSelectEl.parentElement.querySelector('.custom-select-trigger span');
          const selectedOption = Array.from(sheinOutputPageSizeSelectEl.options).find(opt => opt.value === appSettings.sheinOutputPageSize);
          if (customTriggerSpan && selectedOption) {
              customTriggerSpan.textContent = selectedOption.textContent;
              const customOptionsContainer = sheinOutputPageSizeSelectEl.parentElement.querySelector('.custom-select-options');
              const currentCustomSelected = customOptionsContainer.querySelector('.custom-select-option.selected');
              if(currentCustomSelected) currentCustomSelected.classList.remove('selected');
              const newCustomSelected = customOptionsContainer.querySelector(`.custom-select-option[data-value="${appSettings.sheinOutputPageSize}"]`);
              if(newCustomSelected) newCustomSelected.classList.add('selected');
          }
      }

    }

    loadAndApplySettings(); // Call the main function to load settings

  })
</script>

<!-- Toast Notification Container -->
<div id="toastContainer" class="toast-container">
  <!-- Toasts will be dynamically added here by JavaScript -->
</div>
</body>
</html>
